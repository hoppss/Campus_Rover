/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2020-07-31 22:00:41.264225
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[3]);
x6=IKsin(j[0]);
x7=IKsin(j[3]);
x8=((0.0675)*x0);
x9=((0.0405)*x2);
x10=((0.0405)*x4);
x11=((0.0405)*x6);
x12=((0.0405)*x0);
x13=(x1*x4);
x14=(x1*x2);
x15=(x3*x6);
x16=(x0*x3);
IkReal x17=((1.0)*x10);
IkReal x18=(x0*x1);
eetrans[0]=((((-1.0)*x3*x4*x8))+((x14*x8))+(((0.1595)*x16))+((x7*(((((-1.0)*x16*x9))+(((-1.0)*x17*x18))))))+((x5*((((x18*x9))+(((-1.0)*x16*x17)))))));
IkReal x19=(x1*x6);
IkReal x20=((1.0)*x15);
eetrans[1]=(((x7*(((((-1.0)*x20*x9))+(((-1.0)*x10*x19))))))+((x5*((((x19*x9))+(((-1.0)*x10*x20))))))+(((0.0675)*x14*x6))+(((-0.0675)*x15*x4))+(((0.1595)*x15)));
IkReal x21=((1.0)*x9);
eetrans[2]=((0.026)+((x7*(((((-1.0)*x1*x21))+((x10*x3))))))+(((-0.0675)*x2*x3))+(((0.1595)*x1))+((x5*(((((-1.0)*x1*x10))+(((-1.0)*x21*x3))))))+(((-0.0675)*x13)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 4; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=py;
new_pz=((-0.026)+pz);
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=((IKabs(sj3))+(((77.402376252951)*(IKabs(((-0.0215325)+(((-0.0129195)*cj3))))))));
j2eval[1]=((2.77777777777778)+(sj3*sj3)+(cj3*cj3)+(((3.33333333333333)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((IKabs(sj3))+(((77.402376252951)*(IKabs(((-0.0215325)+(((-0.0129195)*cj3))))))));
j2eval[1]=((2.77777777777778)+(sj3*sj3)+(cj3*cj3)+(((3.33333333333333)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x22=IKPowWithIntegerCheck(pz,-1);
if(!x22.valid){
continue;
}
cj1array[0]=((-3.13479623824451)*(x22.value)*(((-0.01924375)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x23=(cj1*pz);
IkReal x24=((162000.0)*cj3);
IkReal x25=((162000.0)*sj3);
IkReal x26=(pz*sj1);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=((IKabs(((((-1.0)*x23*x25))+(((-1.0)*x24*x26))+(((-270000.0)*x26))+(((25839.0)*sj3)))))+(IKabs(((43065.0)+(((-1.0)*x23*x24))+(((25839.0)*cj3))+(((-270000.0)*x23))+((x25*x26))))));
j2eval[2]=IKsign(((24786.0)+(((21870.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x27=pz*pz;
IkReal x28=(pz*sj1);
IkReal x29=((162000000.0)*x27);
j2eval[0]=((-1.13333333333333)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-7906734.0)+(((-6976530.0)*cj3))));
j2eval[2]=((IKabs(((-8541922.5)+(((-6601378.5)*cj3))+(((-51678000.0)*sj3*x28))+((cj3*x29))+(((270000000.0)*x27))+(((-885735.0)*(cj3*cj3))))))+(IKabs((((sj3*x29))+(((-885735.0)*cj3*sj3))+(((-5125153.5)*sj3))+(((51678000.0)*cj3*x28))+(((86130000.0)*x28))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x30=cj1*cj1;
IkReal x31=(cj1*cj3);
IkReal x32=((6000.0)*cj3);
IkReal x33=((6000.0)*sj3);
IkReal x34=(cj1*pz*sj1);
IkReal x35=(pz*x30);
j2eval[0]=(x31+(((1.13333333333333)*cj1)));
j2eval[1]=IKsign(((((12.393)*cj1))+(((10.935)*x31))));
j2eval[2]=((IKabs(((((-10000.0)*x35))+(((957.0)*x31))+(((-1.0)*x32*x35))+(((1595.0)*cj1))+((x33*x34)))))+(IKabs(((((957.0)*cj1*sj3))+(((-10000.0)*x34))+(((-1.0)*x33*x35))+(((-6000.0)*pz*sj1*x31))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x36=((162000.0)*pz);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((24786.0)+(((21870.0)*cj3))));
j2eval[2]=((IKabs(((((-270000.0)*pz))+(((-1.0)*cj3*x36))+(((25839.0)*sj3)))))+(IKabs(((43065.0)+(((25839.0)*cj3))+((sj3*x36))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x37=pz*pz;
IkReal x38=cj3*cj3;
IkReal x39=(cj3*x37);
j2eval[0]=((9.64388050602042)+(((-1.0)*x38))+(((5.18632830361225)*cj3))+(((182.898948331047)*x39))+(((304.831580551745)*x37)));
j2eval[1]=((IKabs(((((8242641.0)*sj3))+(((-268019074.074074)*pz))+(((-9451851851.85185)*(pz*pz*pz))))))+(IKabs(((13737735.0)+(((8242641.0)*cj3))+(((51678000.0)*pz*sj3))))));
j2eval[2]=IKsign(((20184246.5)+(((10854772.5)*cj3))+(((638000000.0)*x37))+(((382800000.0)*x39))+(((-2092959.0)*x38))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x40=pz*pz;
CheckValue<IkReal> x41 = IKatan2WithCheck(IkReal(((13737735.0)+(((8242641.0)*cj3))+(((51678000.0)*pz*sj3)))),IkReal(((((8242641.0)*sj3))+(((-268019074.074074)*pz))+(((-9451851851.85185)*(pz*pz*pz))))),IKFAST_ATAN2_MAGTHRESH);
if(!x41.valid){
continue;
}
CheckValue<IkReal> x42=IKPowWithIntegerCheck(IKsign(((20184246.5)+(((10854772.5)*cj3))+(((382800000.0)*cj3*x40))+(((638000000.0)*x40))+(((-2092959.0)*(cj3*cj3))))),-1);
if(!x42.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x41.value)+(((1.5707963267949)*(x42.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x43=IKsin(j2);
IkReal x44=IKcos(j2);
IkReal x45=((0.0405)*x43);
IkReal x46=(sj3*x44);
evalcond[0]=((-0.1595)+((cj3*x45))+(((0.0675)*x43))+(((0.0405)*x46)));
evalcond[1]=((((0.0675)*x44))+pz+(((-1.0)*sj3*x45))+(((0.0405)*cj3*x44)));
evalcond[2]=((0.0508805)+(((-0.0670047685185185)*x43))+(((-2.36296296296296)*x43*(pz*pz)))+(((-0.0129195)*x46)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x47=((162000.0)*pz);
CheckValue<IkReal> x48 = IKatan2WithCheck(IkReal(((43065.0)+(((25839.0)*cj3))+((sj3*x47)))),IkReal(((((-270000.0)*pz))+(((-1.0)*cj3*x47))+(((25839.0)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x48.valid){
continue;
}
CheckValue<IkReal> x49=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x49.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x48.value)+(((1.5707963267949)*(x49.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x50=IKsin(j2);
IkReal x51=IKcos(j2);
IkReal x52=((0.0405)*x50);
IkReal x53=(sj3*x51);
evalcond[0]=((-0.1595)+(((0.0675)*x50))+((cj3*x52))+(((0.0405)*x53)));
evalcond[1]=((((0.0405)*cj3*x51))+pz+(((0.0675)*x51))+(((-1.0)*sj3*x52)));
evalcond[2]=((0.0508805)+(((-2.36296296296296)*x50*(pz*pz)))+(((-0.0129195)*x53))+(((-0.0670047685185185)*x50)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x54=((162000.0)*pz);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((24786.0)+(((21870.0)*cj3))));
j2eval[2]=((IKabs(((((25839.0)*sj3))+(((270000.0)*pz))+((cj3*x54)))))+(IKabs(((43065.0)+(((25839.0)*cj3))+(((-1.0)*sj3*x54))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x55=pz*pz;
IkReal x56=cj3*cj3;
IkReal x57=(cj3*x55);
j2eval[0]=((-9.64388050602042)+(((-5.18632830361225)*cj3))+(((-182.898948331047)*x57))+x56+(((-304.831580551745)*x55)));
j2eval[1]=IKsign(((-20184246.5)+(((-382800000.0)*x57))+(((2092959.0)*x56))+(((-10854772.5)*cj3))+(((-638000000.0)*x55))));
j2eval[2]=((IKabs(((((-268019074.074074)*pz))+(((-8242641.0)*sj3))+(((-9451851851.85185)*(pz*pz*pz))))))+(IKabs(((-13737735.0)+(((-8242641.0)*cj3))+(((51678000.0)*pz*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x58=pz*pz;
CheckValue<IkReal> x59 = IKatan2WithCheck(IkReal(((-13737735.0)+(((-8242641.0)*cj3))+(((51678000.0)*pz*sj3)))),IkReal(((((-268019074.074074)*pz))+(((-8242641.0)*sj3))+(((-9451851851.85185)*(pz*pz*pz))))),IKFAST_ATAN2_MAGTHRESH);
if(!x59.valid){
continue;
}
CheckValue<IkReal> x60=IKPowWithIntegerCheck(IKsign(((-20184246.5)+(((-10854772.5)*cj3))+(((-638000000.0)*x58))+(((-382800000.0)*cj3*x58))+(((2092959.0)*(cj3*cj3))))),-1);
if(!x60.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x59.value)+(((1.5707963267949)*(x60.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x61=IKsin(j2);
IkReal x62=IKcos(j2);
IkReal x63=((0.0405)*cj3);
IkReal x64=((0.0405)*sj3);
evalcond[0]=((-0.1595)+((x62*x64))+((x61*x63))+(((0.0675)*x61)));
evalcond[1]=((0.0508805)+(((-2.36296296296296)*x61*(pz*pz)))+(((-0.0670047685185185)*x61))+(((-0.0129195)*sj3*x62)));
evalcond[2]=((((-1.0)*x61*x64))+((x62*x63))+(((-1.0)*pz))+(((0.0675)*x62)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x65=((162000.0)*pz);
CheckValue<IkReal> x66 = IKatan2WithCheck(IkReal(((43065.0)+(((25839.0)*cj3))+(((-1.0)*sj3*x65)))),IkReal(((((25839.0)*sj3))+(((270000.0)*pz))+((cj3*x65)))),IKFAST_ATAN2_MAGTHRESH);
if(!x66.valid){
continue;
}
CheckValue<IkReal> x67=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x67.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x66.value)+(((1.5707963267949)*(x67.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x68=IKsin(j2);
IkReal x69=IKcos(j2);
IkReal x70=((0.0405)*cj3);
IkReal x71=((0.0405)*sj3);
evalcond[0]=((-0.1595)+((x69*x71))+((x68*x70))+(((0.0675)*x68)));
evalcond[1]=((0.0508805)+(((-0.0670047685185185)*x68))+(((-2.36296296296296)*x68*(pz*pz)))+(((-0.0129195)*sj3*x69)));
evalcond[2]=(((x69*x70))+(((-1.0)*pz))+(((0.0675)*x69))+(((-1.0)*x68*x71)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x72=cj1*cj1;
IkReal x73=((81.0)*pz);
IkReal x74=(cj1*sj1);
IkReal x75=((135.0)*pz);
IkReal x76=((12.9195)*cj1);
CheckValue<IkReal> x77=IKPowWithIntegerCheck(IKsign(((((12.393)*cj1))+(((10.935)*cj1*cj3)))),-1);
if(!x77.valid){
continue;
}
CheckValue<IkReal> x78 = IKatan2WithCheck(IkReal(((((21.5325)*cj1))+(((-1.0)*cj3*x72*x73))+((sj3*x73*x74))+(((-1.0)*x72*x75))+((cj3*x76)))),IkReal(((((-1.0)*sj3*x72*x73))+(((-1.0)*cj3*x73*x74))+((sj3*x76))+(((-1.0)*x74*x75)))),IKFAST_ATAN2_MAGTHRESH);
if(!x78.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x77.value)))+(x78.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x79=IKcos(j2);
IkReal x80=IKsin(j2);
IkReal x81=((0.0405)*cj1);
IkReal x82=((0.0675)*cj1);
IkReal x83=((0.0405)*sj1);
IkReal x84=(sj3*x79);
IkReal x85=(cj3*x80);
IkReal x86=(sj3*x80);
IkReal x87=(cj3*x79);
IkReal x88=((0.0675)*x79);
IkReal x89=((0.0675)*x80);
evalcond[0]=(x88+((pz*sj1))+(((0.0405)*x87))+(((-0.0405)*x86)));
evalcond[1]=((-0.1595)+((cj1*pz))+x89+(((0.0405)*x84))+(((0.0405)*x85)));
evalcond[2]=((0.03163675)+(((-0.0215325)*x80))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0129195)*x85))+(((-0.0129195)*x84)));
evalcond[3]=((((-1.0)*x81*x86))+((x79*x82))+(((-1.0)*sj1*x89))+(((-1.0)*x83*x85))+(((-1.0)*x83*x84))+((x81*x87))+(((0.1595)*sj1)));
evalcond[4]=((((-1.0)*x83*x86))+(((-0.1595)*cj1))+((x81*x84))+((x81*x85))+((sj1*x88))+pz+((x83*x87))+((x80*x82)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x90=pz*pz;
IkReal x91=(pz*sj1);
IkReal x92=((162000000.0)*x90);
CheckValue<IkReal> x93 = IKatan2WithCheck(IkReal(((-8541922.5)+(((270000000.0)*x90))+((cj3*x92))+(((-51678000.0)*sj3*x91))+(((-6601378.5)*cj3))+(((-885735.0)*(cj3*cj3))))),IkReal(((((51678000.0)*cj3*x91))+((sj3*x92))+(((-885735.0)*cj3*sj3))+(((86130000.0)*x91))+(((-5125153.5)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x93.valid){
continue;
}
CheckValue<IkReal> x94=IKPowWithIntegerCheck(IKsign(((-7906734.0)+(((-6976530.0)*cj3)))),-1);
if(!x94.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x93.value)+(((1.5707963267949)*(x94.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x95=IKcos(j2);
IkReal x96=IKsin(j2);
IkReal x97=((0.0405)*cj1);
IkReal x98=((0.0675)*cj1);
IkReal x99=((0.0405)*sj1);
IkReal x100=(sj3*x95);
IkReal x101=(cj3*x96);
IkReal x102=(sj3*x96);
IkReal x103=(cj3*x95);
IkReal x104=((0.0675)*x95);
IkReal x105=((0.0675)*x96);
evalcond[0]=((((0.0405)*x103))+x104+(((-0.0405)*x102))+((pz*sj1)));
evalcond[1]=((-0.1595)+(((0.0405)*x101))+(((0.0405)*x100))+x105+((cj1*pz)));
evalcond[2]=((0.03163675)+(((-0.0215325)*x96))+(((-0.0129195)*x100))+(((-0.0129195)*x101))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))));
evalcond[3]=((((-1.0)*x102*x97))+((x103*x97))+(((0.1595)*sj1))+(((-1.0)*x101*x99))+((x95*x98))+(((-1.0)*x100*x99))+(((-1.0)*sj1*x105)));
evalcond[4]=(((sj1*x104))+((x96*x98))+(((-1.0)*x102*x99))+((x100*x97))+(((-0.1595)*cj1))+((x103*x99))+((x101*x97))+pz);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x106=(cj1*pz);
IkReal x107=((162000.0)*cj3);
IkReal x108=((162000.0)*sj3);
IkReal x109=(pz*sj1);
CheckValue<IkReal> x110 = IKatan2WithCheck(IkReal(((43065.0)+(((-270000.0)*x106))+(((25839.0)*cj3))+(((-1.0)*x106*x107))+((x108*x109)))),IkReal(((((-270000.0)*x109))+(((-1.0)*x107*x109))+(((-1.0)*x106*x108))+(((25839.0)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x110.valid){
continue;
}
CheckValue<IkReal> x111=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x111.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x110.value)+(((1.5707963267949)*(x111.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x112=IKcos(j2);
IkReal x113=IKsin(j2);
IkReal x114=((0.0405)*cj1);
IkReal x115=((0.0675)*cj1);
IkReal x116=((0.0405)*sj1);
IkReal x117=(sj3*x112);
IkReal x118=(cj3*x113);
IkReal x119=(sj3*x113);
IkReal x120=(cj3*x112);
IkReal x121=((0.0675)*x112);
IkReal x122=((0.0675)*x113);
evalcond[0]=((((0.0405)*x120))+x121+(((-0.0405)*x119))+((pz*sj1)));
evalcond[1]=((-0.1595)+(((0.0405)*x117))+(((0.0405)*x118))+x122+((cj1*pz)));
evalcond[2]=((0.03163675)+(((-0.0215325)*x113))+(((-0.0129195)*x118))+(((-0.0129195)*x117))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))));
evalcond[3]=((((-1.0)*sj1*x122))+((x112*x115))+(((-1.0)*x116*x118))+(((-1.0)*x116*x117))+((x114*x120))+(((-1.0)*x114*x119))+(((0.1595)*sj1)));
evalcond[4]=(((x114*x117))+((x114*x118))+(((-1.0)*x116*x119))+(((-0.1595)*cj1))+((x113*x115))+pz+((x116*x120))+((sj1*x121)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x123=((-0.0215325)+(((-0.0129195)*cj3)));
CheckValue<IkReal> x126 = IKatan2WithCheck(IkReal(((-0.0129195)*sj3)),IkReal(x123),IKFAST_ATAN2_MAGTHRESH);
if(!x126.valid){
continue;
}
IkReal x124=((1.0)*(x126.value));
if((((((0.00016691348025)*(sj3*sj3)))+(x123*x123))) < -0.00001)
continue;
CheckValue<IkReal> x127=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.00016691348025)*(sj3*sj3)))+(x123*x123)))),-1);
if(!x127.valid){
continue;
}
if( (((x127.value)*(((0.03163675)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))))))) < -1-IKFAST_SINCOS_THRESH || (((x127.value)*(((0.03163675)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x125=IKasin(((x127.value)*(((0.03163675)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))))));
j2array[0]=((((-1.0)*x124))+(((-1.0)*x125)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x124))+x125);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x128=((0.0405)*sj3);
IkReal x129=((0.0405)*cj3);
j1eval[0]=pz;
j1eval[1]=((IKabs((((sj2*x128))+(((-1.0)*cj2*x129))+(((-0.0675)*cj2)))))+(IKabs(((0.1595)+(((-1.0)*sj2*x129))+(((-1.0)*cj2*x128))+(((-0.0675)*sj2))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x130=(pz*sj2);
j1eval[0]=((((-1.66666666666667)*x130))+(((-1.0)*cj2*pz*sj3))+(((-1.0)*cj3*x130))+(((3.93827160493827)*pz)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x131=((0.0405)*sj3);
j1eval[0]=((IKabs(((-0.1595)+((cj2*x131))+(((0.210046296296296)*sj2)))))+(IKabs(((((-1.0)*sj2*x131))+(((0.210046296296296)*cj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x132=((0.0405)*sj3);
j1eval[0]=((IKabs(((((-1.0)*sj2*x132))+(((0.210046296296296)*cj2)))))+(IKabs(((0.1595)+(((-0.210046296296296)*sj2))+(((-1.0)*cj2*x132))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x133=((0.0405)*sj3);
CheckValue<IkReal> x135 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x133))+(((0.210046296296296)*cj2)))),IkReal(((0.1595)+(((-0.210046296296296)*sj2))+(((-1.0)*cj2*x133)))),IKFAST_ATAN2_MAGTHRESH);
if(!x135.valid){
continue;
}
IkReal x134=x135.value;
j1array[0]=((-1.0)*x134);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x134)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x136=IKcos(j1);
IkReal x137=IKsin(j1);
IkReal x138=((0.0405)*sj3);
evalcond[0]=(((cj2*x136*x138))+(((0.210046296296296)*sj2*x136))+(((-0.1595)*x136))+(((-1.0)*sj2*x137*x138))+(((0.210046296296296)*cj2*x137)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x139=((0.0405)*sj3);
CheckValue<IkReal> x141 = IKatan2WithCheck(IkReal(((-0.1595)+((cj2*x139))+(((0.210046296296296)*sj2)))),IkReal(((((-1.0)*sj2*x139))+(((0.210046296296296)*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x141.valid){
continue;
}
IkReal x140=x141.value;
j1array[0]=((-1.0)*x140);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x140)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x142=IKcos(j1);
IkReal x143=IKsin(j1);
IkReal x144=((0.0405)*sj3);
evalcond[0]=((((-0.210046296296296)*sj2*x143))+(((0.210046296296296)*cj2*x142))+(((-1.0)*cj2*x143*x144))+(((0.1595)*x143))+(((-1.0)*sj2*x142*x144)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x145=pz*pz;
IkReal x146=(cj2*cj3);
IkReal x147=(sj2*sj3);
IkReal x148=(pz*sj2);
IkReal x149=((40.5)*x145);
CheckValue<IkReal> x150=IKPowWithIntegerCheck(((((-21.5325)*x148))+(((50.8805)*pz))+(((-12.9195)*cj3*x148))+(((-12.9195)*cj2*pz*sj3))),-1);
if(!x150.valid){
continue;
}
CheckValue<IkReal> x151=IKPowWithIntegerCheck(pz,-1);
if(!x151.valid){
continue;
}
if( IKabs(((x150.value)*(((((-1.298953125)*cj2))+(((0.779371875)*x147))+(((-67.5)*cj2*x145))+(((-0.410315625)*x146))+(((-0.22143375)*cj3*x147))+((x147*x149))+(((-1.0)*x146*x149))+(((0.22143375)*cj3*x146)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00313479623824451)*(x151.value)*(((19.24375)+(((1000.0)*x145))+(((-5.4675)*cj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x150.value)*(((((-1.298953125)*cj2))+(((0.779371875)*x147))+(((-67.5)*cj2*x145))+(((-0.410315625)*x146))+(((-0.22143375)*cj3*x147))+((x147*x149))+(((-1.0)*x146*x149))+(((0.22143375)*cj3*x146))))))+IKsqr(((0.00313479623824451)*(x151.value)*(((19.24375)+(((1000.0)*x145))+(((-5.4675)*cj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x150.value)*(((((-1.298953125)*cj2))+(((0.779371875)*x147))+(((-67.5)*cj2*x145))+(((-0.410315625)*x146))+(((-0.22143375)*cj3*x147))+((x147*x149))+(((-1.0)*x146*x149))+(((0.22143375)*cj3*x146))))), ((0.00313479623824451)*(x151.value)*(((19.24375)+(((1000.0)*x145))+(((-5.4675)*cj3))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x152=IKcos(j1);
IkReal x153=IKsin(j1);
IkReal x154=((0.0405)*cj3);
IkReal x155=((0.0675)*sj2);
IkReal x156=((0.0675)*cj2);
IkReal x157=((0.0405)*cj2*sj3);
IkReal x158=(cj2*x152);
IkReal x159=(sj2*x153);
IkReal x160=((0.0405)*sj2*sj3);
IkReal x161=(pz*x152);
evalcond[0]=((-0.01924375)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((0.319)*x161)));
evalcond[1]=((((-1.0)*x160))+((cj2*x154))+x156+((pz*x153)));
evalcond[2]=((-0.1595)+x161+x157+x155+((sj2*x154)));
evalcond[3]=((((-1.0)*x154*x159))+(((-1.0)*x153*x155))+(((-1.0)*x153*x157))+(((-1.0)*x152*x160))+((x152*x156))+((x154*x158))+(((0.1595)*x153)));
evalcond[4]=(((x153*x156))+((cj2*x153*x154))+(((-0.1595)*x152))+((x152*x155))+((x152*x157))+(((-0.0405)*sj3*x159))+pz+((sj2*x152*x154)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x163=IKPowWithIntegerCheck(pz,-1);
if(!x163.valid){
continue;
}
IkReal x162=x163.value;
CheckValue<IkReal> x164=IKPowWithIntegerCheck(x162,-2);
if(!x164.valid){
continue;
}
if( IKabs((x162*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00313479623824451)*x162*(((19.24375)+(((1000.0)*(x164.value)))+(((-5.4675)*cj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x162*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2))))))+IKsqr(((0.00313479623824451)*x162*(((19.24375)+(((1000.0)*(x164.value)))+(((-5.4675)*cj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x162*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2))))), ((0.00313479623824451)*x162*(((19.24375)+(((1000.0)*(x164.value)))+(((-5.4675)*cj3))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x165=IKcos(j1);
IkReal x166=IKsin(j1);
IkReal x167=((0.0405)*cj3);
IkReal x168=((0.0675)*sj2);
IkReal x169=((0.0675)*cj2);
IkReal x170=((0.0405)*cj2*sj3);
IkReal x171=(cj2*x165);
IkReal x172=(sj2*x166);
IkReal x173=((0.0405)*sj2*sj3);
IkReal x174=(pz*x165);
evalcond[0]=((-0.01924375)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((0.319)*x174)));
evalcond[1]=(((pz*x166))+(((-1.0)*x173))+((cj2*x167))+x169);
evalcond[2]=((-0.1595)+x170+x174+x168+((sj2*x167)));
evalcond[3]=((((-1.0)*x166*x168))+((x167*x171))+(((0.1595)*x166))+((x165*x169))+(((-1.0)*x166*x170))+(((-1.0)*x167*x172))+(((-1.0)*x165*x173)));
evalcond[4]=((((-0.1595)*x165))+(((-0.0405)*sj3*x172))+((x166*x169))+pz+((x165*x170))+((x165*x168))+((sj2*x165*x167))+((cj2*x166*x167)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x175=((0.0405)*cj2);
IkReal x176=((0.0405)*sj2);
CheckValue<IkReal> x177 = IKatan2WithCheck(IkReal(((((-1.0)*cj3*x175))+(((-0.0675)*cj2))+((sj3*x176)))),IkReal(((0.1595)+(((-1.0)*cj3*x176))+(((-0.0675)*sj2))+(((-1.0)*sj3*x175)))),IKFAST_ATAN2_MAGTHRESH);
if(!x177.valid){
continue;
}
CheckValue<IkReal> x178=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x178.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x177.value)+(((1.5707963267949)*(x178.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x179=IKcos(j1);
IkReal x180=IKsin(j1);
IkReal x181=((0.0405)*cj3);
IkReal x182=((0.0675)*sj2);
IkReal x183=((0.0675)*cj2);
IkReal x184=((0.0405)*cj2*sj3);
IkReal x185=(cj2*x179);
IkReal x186=(sj2*x180);
IkReal x187=((0.0405)*sj2*sj3);
IkReal x188=(pz*x179);
evalcond[0]=((-0.01924375)+(((0.319)*x188))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))));
evalcond[1]=(((pz*x180))+(((-1.0)*x187))+x183+((cj2*x181)));
evalcond[2]=((-0.1595)+((sj2*x181))+x184+x182+x188);
evalcond[3]=(((x179*x183))+(((-1.0)*x180*x182))+(((-1.0)*x180*x184))+(((0.1595)*x180))+(((-1.0)*x179*x187))+((x181*x185))+(((-1.0)*x181*x186)));
evalcond[4]=(((sj2*x179*x181))+((x180*x183))+(((-0.1595)*x179))+(((-0.0405)*sj3*x186))+((x179*x182))+((x179*x184))+pz+((cj2*x180*x181)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x189=((-0.0215325)+(((-0.0129195)*cj3)));
CheckValue<IkReal> x192 = IKatan2WithCheck(IkReal(((-0.0129195)*sj3)),IkReal(x189),IKFAST_ATAN2_MAGTHRESH);
if(!x192.valid){
continue;
}
IkReal x190=((1.0)*(x192.value));
if((((((0.00016691348025)*(sj3*sj3)))+(x189*x189))) < -0.00001)
continue;
CheckValue<IkReal> x193=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.00016691348025)*(sj3*sj3)))+(x189*x189)))),-1);
if(!x193.valid){
continue;
}
if( (((x193.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x193.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x191=IKasin(((x193.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x191))+(((-1.0)*x190)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x190))+x191);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x194=sj2*sj2;
IkReal x195=cj2*cj2;
IkReal x196=sj3*sj3;
IkReal x197=cj3*cj3;
IkReal x198=(cj3*sj2);
IkReal x199=((3.33333333333333)*cj3);
IkReal x200=((0.0405)*cj2);
j1eval[0]=((IKabs(((-0.1595)+((sj3*x200))+(((0.0405)*x198))+(((0.0675)*sj2)))))+(IKabs((((cj3*x200))+(((0.0675)*cj2))+(((-0.0405)*sj2*sj3))))));
j1eval[1]=((15.5099832342631)+(((-7.87654320987654)*x198))+(((-7.87654320987654)*cj2*sj3))+(((-13.1275720164609)*sj2))+((x195*x199))+((x195*x196))+((x195*x197))+((x194*x199))+((x194*x196))+((x194*x197))+(((2.77777777777778)*x195))+(((2.77777777777778)*x194)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x201=((0.0405)*sj3);
IkReal x202=((0.0405)*cj3);
j1eval[0]=pz;
j1eval[1]=((IKabs(((((-1.0)*cj2*x202))+(((-0.0675)*cj2))+((sj2*x201)))))+(IKabs(((0.1595)+(((-0.0675)*sj2))+(((-1.0)*cj2*x201))+(((-1.0)*sj2*x202))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x203=(pz*sj2);
j1eval[0]=((((-1.0)*cj2*pz*sj3))+(((3.93827160493827)*pz))+(((-1.0)*cj3*x203))+(((-1.66666666666667)*x203)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x204=((0.0405)*sj3);
j1eval[0]=((IKabs(((((0.210046296296296)*cj2))+(((-1.0)*sj2*x204)))))+(IKabs(((-0.1595)+((cj2*x204))+(((0.210046296296296)*sj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x205=((0.0405)*sj3);
j1eval[0]=((IKabs(((((0.210046296296296)*cj2))+(((-1.0)*sj2*x205)))))+(IKabs(((0.1595)+(((-0.210046296296296)*sj2))+(((-1.0)*cj2*x205))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x206=((0.0405)*sj3);
CheckValue<IkReal> x208 = IKatan2WithCheck(IkReal(((((0.210046296296296)*cj2))+(((-1.0)*sj2*x206)))),IkReal(((0.1595)+(((-0.210046296296296)*sj2))+(((-1.0)*cj2*x206)))),IKFAST_ATAN2_MAGTHRESH);
if(!x208.valid){
continue;
}
IkReal x207=x208.value;
j1array[0]=((-1.0)*x207);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x207)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x209=IKcos(j1);
IkReal x210=IKsin(j1);
IkReal x211=((0.0405)*sj3);
evalcond[0]=((((-0.1595)*x209))+(((-1.0)*sj2*x210*x211))+(((0.210046296296296)*sj2*x209))+((cj2*x209*x211))+(((0.210046296296296)*cj2*x210)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x212=((0.0405)*sj3);
CheckValue<IkReal> x214 = IKatan2WithCheck(IkReal(((-0.1595)+((cj2*x212))+(((0.210046296296296)*sj2)))),IkReal(((((-1.0)*sj2*x212))+(((0.210046296296296)*cj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x214.valid){
continue;
}
IkReal x213=x214.value;
j1array[0]=((-1.0)*x213);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x213)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x215=IKcos(j1);
IkReal x216=IKsin(j1);
IkReal x217=((0.0405)*sj3);
evalcond[0]=((((-1.0)*sj2*x215*x217))+(((-0.210046296296296)*sj2*x216))+(((-1.0)*cj2*x216*x217))+(((0.210046296296296)*cj2*x215))+(((0.1595)*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x218=pz*pz;
IkReal x219=(cj2*cj3);
IkReal x220=(sj2*sj3);
IkReal x221=(pz*sj2);
IkReal x222=((40.5)*x218);
CheckValue<IkReal> x223=IKPowWithIntegerCheck(((((-21.5325)*x221))+(((-12.9195)*cj3*x221))+(((50.8805)*pz))+(((-12.9195)*cj2*pz*sj3))),-1);
if(!x223.valid){
continue;
}
CheckValue<IkReal> x224=IKPowWithIntegerCheck(pz,-1);
if(!x224.valid){
continue;
}
if( IKabs(((x223.value)*(((((-0.22143375)*cj3*x220))+(((-1.298953125)*cj2))+(((-67.5)*cj2*x218))+(((-1.0)*x219*x222))+((x220*x222))+(((0.22143375)*cj3*x219))+(((0.779371875)*x220))+(((-0.410315625)*x219)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00313479623824451)*(x224.value)*(((19.24375)+(((1000.0)*x218))+(((-5.4675)*cj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x223.value)*(((((-0.22143375)*cj3*x220))+(((-1.298953125)*cj2))+(((-67.5)*cj2*x218))+(((-1.0)*x219*x222))+((x220*x222))+(((0.22143375)*cj3*x219))+(((0.779371875)*x220))+(((-0.410315625)*x219))))))+IKsqr(((0.00313479623824451)*(x224.value)*(((19.24375)+(((1000.0)*x218))+(((-5.4675)*cj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x223.value)*(((((-0.22143375)*cj3*x220))+(((-1.298953125)*cj2))+(((-67.5)*cj2*x218))+(((-1.0)*x219*x222))+((x220*x222))+(((0.22143375)*cj3*x219))+(((0.779371875)*x220))+(((-0.410315625)*x219))))), ((0.00313479623824451)*(x224.value)*(((19.24375)+(((1000.0)*x218))+(((-5.4675)*cj3))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x225=IKcos(j1);
IkReal x226=IKsin(j1);
IkReal x227=((0.0405)*cj3);
IkReal x228=((0.0675)*sj2);
IkReal x229=((0.0675)*cj2);
IkReal x230=((0.0405)*cj2*sj3);
IkReal x231=(cj2*x225);
IkReal x232=(sj2*x226);
IkReal x233=((0.0405)*sj2*sj3);
IkReal x234=(pz*x225);
evalcond[0]=((-0.01924375)+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((0.319)*x234)));
evalcond[1]=(((cj2*x227))+((pz*x226))+(((-1.0)*x233))+x229);
evalcond[2]=((-0.1595)+x228+x230+x234+((sj2*x227)));
evalcond[3]=((((-1.0)*x225*x233))+((x225*x229))+(((-1.0)*x227*x232))+(((-1.0)*x226*x230))+((x227*x231))+(((0.1595)*x226))+(((-1.0)*x226*x228)));
evalcond[4]=(((sj2*x225*x227))+((x225*x228))+(((-0.0405)*sj3*x232))+((x225*x230))+((cj2*x226*x227))+pz+(((-0.1595)*x225))+((x226*x229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x236=IKPowWithIntegerCheck(pz,-1);
if(!x236.valid){
continue;
}
IkReal x235=x236.value;
CheckValue<IkReal> x237=IKPowWithIntegerCheck(x235,-2);
if(!x237.valid){
continue;
}
if( IKabs((x235*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00313479623824451)*x235*(((19.24375)+(((-5.4675)*cj3))+(((1000.0)*(x237.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x235*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2))))))+IKsqr(((0.00313479623824451)*x235*(((19.24375)+(((-5.4675)*cj3))+(((1000.0)*(x237.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x235*(((((-0.0405)*cj2*cj3))+(((0.0405)*sj2*sj3))+(((-0.0675)*cj2))))), ((0.00313479623824451)*x235*(((19.24375)+(((-5.4675)*cj3))+(((1000.0)*(x237.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x238=IKcos(j1);
IkReal x239=IKsin(j1);
IkReal x240=((0.0405)*cj3);
IkReal x241=((0.0675)*sj2);
IkReal x242=((0.0675)*cj2);
IkReal x243=((0.0405)*cj2*sj3);
IkReal x244=(cj2*x238);
IkReal x245=(sj2*x239);
IkReal x246=((0.0405)*sj2*sj3);
IkReal x247=(pz*x238);
evalcond[0]=((-0.01924375)+(((0.319)*x247))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))));
evalcond[1]=(((pz*x239))+x242+(((-1.0)*x246))+((cj2*x240)));
evalcond[2]=((-0.1595)+((sj2*x240))+x243+x241+x247);
evalcond[3]=(((x240*x244))+((x238*x242))+(((0.1595)*x239))+(((-1.0)*x238*x246))+(((-1.0)*x240*x245))+(((-1.0)*x239*x243))+(((-1.0)*x239*x241)));
evalcond[4]=(((x238*x241))+((x238*x243))+((x239*x242))+(((-0.0405)*sj3*x245))+((cj2*x239*x240))+pz+((sj2*x238*x240))+(((-0.1595)*x238)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x248=((0.0405)*cj2);
IkReal x249=((0.0405)*sj2);
CheckValue<IkReal> x250 = IKatan2WithCheck(IkReal((((sj3*x249))+(((-1.0)*cj3*x248))+(((-0.0675)*cj2)))),IkReal(((0.1595)+(((-1.0)*sj3*x248))+(((-1.0)*cj3*x249))+(((-0.0675)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x250.valid){
continue;
}
CheckValue<IkReal> x251=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x251.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x250.value)+(((1.5707963267949)*(x251.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x252=IKcos(j1);
IkReal x253=IKsin(j1);
IkReal x254=((0.0405)*cj3);
IkReal x255=((0.0675)*sj2);
IkReal x256=((0.0675)*cj2);
IkReal x257=((0.0405)*cj2*sj3);
IkReal x258=(cj2*x252);
IkReal x259=(sj2*x253);
IkReal x260=((0.0405)*sj2*sj3);
IkReal x261=(pz*x252);
evalcond[0]=((-0.01924375)+(((0.319)*x261))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz))));
evalcond[1]=(((cj2*x254))+((pz*x253))+x256+(((-1.0)*x260)));
evalcond[2]=((-0.1595)+x255+x257+x261+((sj2*x254)));
evalcond[3]=((((-1.0)*x254*x259))+(((0.1595)*x253))+((x252*x256))+((x254*x258))+(((-1.0)*x252*x260))+(((-1.0)*x253*x255))+(((-1.0)*x253*x257)));
evalcond[4]=((((-0.0405)*sj3*x259))+((cj2*x253*x254))+((sj2*x252*x254))+((x253*x256))+(((-0.1595)*x252))+pz+((x252*x257))+((x252*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x262=((0.0405)*cj2);
IkReal x263=((0.0405)*sj2);
IkReal x264=((((-1.0)*sj3*x263))+(((0.0675)*cj2))+((cj3*x262)));
IkReal x265=((-0.1595)+((sj3*x262))+(((0.0675)*sj2))+((cj3*x263)));
CheckValue<IkReal> x268 = IKatan2WithCheck(IkReal(x265),IkReal(x264),IKFAST_ATAN2_MAGTHRESH);
if(!x268.valid){
continue;
}
IkReal x266=((1.0)*(x268.value));
if((((x264*x264)+(x265*x265))) < -0.00001)
continue;
CheckValue<IkReal> x269=IKPowWithIntegerCheck(IKabs(IKsqrt(((x264*x264)+(x265*x265)))),-1);
if(!x269.valid){
continue;
}
if( ((pz*(x269.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x269.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x267=IKasin((pz*(x269.value)));
j1array[0]=((((-1.0)*x267))+(((-1.0)*x266)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x267+(((-1.0)*x266)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x270=((81.0)*py);
IkReal x271=(sj2*sj3);
IkReal x272=(cj2*cj3);
IkReal x273=((81.0)*px);
IkReal x274=((135.0)*cj2);
IkReal x275=((2000.0)*pz*sj1);
IkReal x276=(((cj1*(px*px)))+((cj1*(py*py))));
j0eval[0]=x276;
j0eval[1]=((IKabs((((x272*x273))+((px*x274))+((px*x275))+(((-1.0)*x271*x273)))))+(IKabs((((x270*x272))+((py*x274))+((py*x275))+(((-1.0)*x270*x271))))));
j0eval[2]=IKsign(x276);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x277=((135.0)*sj2);
IkReal x278=((81.0)*cj3*sj2);
IkReal x279=((2000.0)*cj1*pz);
IkReal x280=((81.0)*cj2*sj3);
IkReal x281=(((sj1*(py*py)))+((sj1*(px*px))));
j0eval[0]=x281;
j0eval[1]=((IKabs(((((-1.0)*px*x280))+(((-1.0)*px*x277))+(((-1.0)*px*x279))+(((-1.0)*px*x278))+(((319.0)*px)))))+(IKabs(((((-1.0)*py*x280))+(((319.0)*py))+(((-1.0)*py*x277))+(((-1.0)*py*x278))+(((-1.0)*py*x279))))));
j0eval[2]=IKsign(x281);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x282=px*px;
IkReal x283=pz*pz;
IkReal x284=py*py;
IkReal x285=((800000.0)*px);
IkReal x286=((800000.0)*py);
IkReal x287=((4374.0)*cj3);
IkReal x288=(sj1*x282);
IkReal x289=((255200.0)*cj1*pz);
IkReal x290=(sj1*x284);
j0eval[0]=(x290+x288);
j0eval[1]=((IKabs(((((15395.0)*py))+((x286*(py*py)))+(((-1.0)*py*x287))+(((-1.0)*py*x289))+((x282*x286))+((x283*x286)))))+(IKabs((((x284*x285))+(((-1.0)*px*x289))+(((-1.0)*px*x287))+(((15395.0)*px))+((x285*(px*px)))+((x283*x285))))));
j0eval[2]=IKsign(((((319.0)*x288))+(((319.0)*x290))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x291=((5.0)*cj2);
IkReal x292=((3.0)*cj2*cj3);
IkReal x293=((3.0)*sj2*sj3);
IkReal x294=((px*px)+(py*py));
j0eval[0]=x294;
j0eval[1]=((IKabs((((px*x292))+((px*x291))+(((-1.0)*px*x293)))))+(IKabs(((((-1.0)*py*x293))+((py*x292))+((py*x291))))));
j0eval[2]=IKsign(x294);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=0;
sj3=0;
cj3=1.0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x296 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x296.valid){
continue;
}
IkReal x295=x296.value;
j0array[0]=((-1.0)*x295);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x295)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=0;
sj3=0;
cj3=1.0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x298 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x298.valid){
continue;
}
IkReal x297=x298.value;
j0array[0]=((-1.0)*x297);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x297)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x300 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x300.valid){
continue;
}
IkReal x299=x300.value;
j0array[0]=((-1.0)*x299);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x299)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x302 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x302.valid){
continue;
}
IkReal x301=x302.value;
j0array[0]=((-1.0)*x301);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x301)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x303=((0.0675)*cj2);
IkReal x304=((0.0405)*sj2*sj3);
IkReal x305=((0.0405)*cj2*cj3);
CheckValue<IkReal> x306 = IKatan2WithCheck(IkReal(((((-1.0)*py*x304))+((py*x305))+((py*x303)))),IkReal((((px*x303))+((px*x305))+(((-1.0)*px*x304)))),IKFAST_ATAN2_MAGTHRESH);
if(!x306.valid){
continue;
}
CheckValue<IkReal> x307=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x307.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x306.value)+(((1.5707963267949)*(x307.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x308=IKcos(j0);
IkReal x309=IKsin(j0);
IkReal x310=((1.0)*x308);
evalcond[0]=(((px*x309))+(((-1.0)*py*x310)));
evalcond[1]=((((-1.0)*py*x309))+(((0.0675)*cj2))+(((-0.0405)*sj2*sj3))+(((0.0405)*cj2*cj3))+(((-1.0)*px*x310)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x311=(cj2*px);
IkReal x312=((3.0)*cj3);
IkReal x313=(cj2*py);
IkReal x314=((3.0)*sj2*sj3);
IkReal x315=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x315;
j0eval[1]=((IKabs((((x312*x313))+(((-1.0)*py*x314))+(((5.0)*x313)))))+(IKabs((((x311*x312))+(((5.0)*x311))+(((-1.0)*px*x314))))));
j0eval[2]=IKsign(x315);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=0;
sj3=0;
cj3=1.0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x317 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x317.valid){
continue;
}
IkReal x316=x317.value;
j0array[0]=((-1.0)*x316);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x316)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((px*(IKsin(j0))))+(((-1.0)*py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=0;
sj3=0;
cj3=1.0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x319 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x319.valid){
continue;
}
IkReal x318=x319.value;
j0array[0]=((-1.0)*x318);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x318)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((px*(IKsin(j0))))+(((-1.0)*py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=1.5707963267949;
sj2=1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x321 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x321.valid){
continue;
}
IkReal x320=x321.value;
j0array[0]=((-1.0)*x320);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x320)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((px*(IKsin(j0))))+(((-1.0)*py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=-1.5707963267949;
sj2=-1.0;
cj2=0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x323 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x323.valid){
continue;
}
IkReal x322=x323.value;
j0array[0]=((-1.0)*x322);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x322)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=(((px*(IKsin(j0))))+(((-1.0)*py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x324=((0.0675)*cj2);
IkReal x325=((0.0405)*sj2*sj3);
IkReal x326=((0.0405)*cj2*cj3);
CheckValue<IkReal> x327=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x327.valid){
continue;
}
CheckValue<IkReal> x328 = IKatan2WithCheck(IkReal((((py*x326))+((py*x324))+(((-1.0)*py*x325)))),IkReal(((((-1.0)*px*x325))+((px*x324))+((px*x326)))),IKFAST_ATAN2_MAGTHRESH);
if(!x328.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x327.value)))+(x328.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x329=IKsin(j0);
IkReal x330=IKcos(j0);
evalcond[0]=((((-1.0)*py*x330))+((px*x329)));
evalcond[1]=(((px*x330))+(((0.0675)*cj2))+((py*x329))+(((-0.0405)*sj2*sj3))+(((0.0405)*cj2*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x331=((135.0)*sj2);
IkReal x332=((81.0)*cj3*sj2);
IkReal x333=((81.0)*cj2*sj3);
IkReal x334=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x334;
j0eval[1]=IKsign(x334);
j0eval[2]=((IKabs((((px*x333))+((px*x331))+((px*x332))+(((-319.0)*px)))))+(IKabs(((((-319.0)*py))+((py*x333))+((py*x331))+((py*x332))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x335=px*px;
IkReal x336=py*py;
IkReal x337=pz*pz;
IkReal x338=((4374.0)*cj3);
IkReal x339=((800000.0)*px);
IkReal x340=((800000.0)*py);
j0eval[0]=((((-1.0)*x336))+(((-1.0)*x335)));
j0eval[1]=IKsign(((((-319.0)*x336))+(((-319.0)*x335))));
j0eval[2]=((IKabs(((((-1.0)*x335*x340))+(((-15395.0)*py))+(((-1.0)*x337*x340))+((py*x338))+(((-1.0)*x340*(py*py))))))+(IKabs(((((-1.0)*x337*x339))+(((-15395.0)*px))+((px*x338))+(((-1.0)*x339*(px*px)))+(((-1.0)*x336*x339))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x341=pz*pz;
IkReal x342=px*px;
IkReal x343=py*py;
IkReal x344=((5.4675)*cj3);
IkReal x345=((1000.0)*py);
IkReal x346=((1000.0)*px);
CheckValue<IkReal> x347=IKPowWithIntegerCheck(IKsign(((((-319.0)*x342))+(((-319.0)*x343)))),-1);
if(!x347.valid){
continue;
}
CheckValue<IkReal> x348 = IKatan2WithCheck(IkReal((((py*x344))+(((-1.0)*x345*(py*py)))+(((-1.0)*x341*x345))+(((-19.24375)*py))+(((-1.0)*x342*x345)))),IkReal(((((-1.0)*x346*(px*px)))+(((-1.0)*x341*x346))+(((-1.0)*x343*x346))+(((-19.24375)*px))+((px*x344)))),IKFAST_ATAN2_MAGTHRESH);
if(!x348.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x347.value)))+(x348.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x349=IKsin(j0);
IkReal x350=IKcos(j0);
IkReal x351=(py*x349);
IkReal x352=(px*x350);
evalcond[0]=((((-1.0)*py*x350))+((px*x349)));
evalcond[1]=((-0.1595)+(((0.0405)*cj2*sj3))+(((0.0405)*cj3*sj2))+x351+x352+(((0.0675)*sj2)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x351))+(((0.319)*x352))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x353=((0.0675)*sj2);
IkReal x354=((0.0405)*cj3*sj2);
IkReal x355=((0.0405)*cj2*sj3);
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal((((py*x353))+((py*x354))+((py*x355))+(((-0.1595)*py)))),IkReal((((px*x354))+((px*x355))+((px*x353))+(((-0.1595)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
CheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x357.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x356.value)+(((1.5707963267949)*(x357.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x358=IKsin(j0);
IkReal x359=IKcos(j0);
IkReal x360=(py*x358);
IkReal x361=(px*x359);
evalcond[0]=(((px*x358))+(((-1.0)*py*x359)));
evalcond[1]=((-0.1595)+(((0.0405)*cj2*sj3))+(((0.0405)*cj3*sj2))+x360+x361+(((0.0675)*sj2)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x361))+(((0.319)*x360))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x362=((135.0)*sj2);
IkReal x363=((81.0)*cj3*sj2);
IkReal x364=((81.0)*cj2*sj3);
IkReal x365=((px*px)+(py*py));
j0eval[0]=x365;
j0eval[1]=IKsign(x365);
j0eval[2]=((IKabs((((px*x363))+((px*x362))+((px*x364))+(((-319.0)*px)))))+(IKabs((((py*x364))+((py*x363))+((py*x362))+(((-319.0)*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x366=px*px;
IkReal x367=py*py;
IkReal x368=pz*pz;
IkReal x369=((4374.0)*cj3);
IkReal x370=((800000.0)*px);
IkReal x371=((800000.0)*py);
j0eval[0]=(x366+x367);
j0eval[1]=IKsign(((((319.0)*x366))+(((319.0)*x367))));
j0eval[2]=((IKabs(((((-1.0)*x368*x370))+(((-15395.0)*px))+(((-1.0)*x370*(px*px)))+(((-1.0)*x367*x370))+((px*x369)))))+(IKabs(((((-1.0)*x368*x371))+(((-15395.0)*py))+(((-1.0)*x371*(py*py)))+(((-1.0)*x366*x371))+((py*x369))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x372=pz*pz;
IkReal x373=px*px;
IkReal x374=py*py;
IkReal x375=((5.4675)*cj3);
IkReal x376=((1000.0)*py);
IkReal x377=((1000.0)*px);
CheckValue<IkReal> x378=IKPowWithIntegerCheck(IKsign(((((319.0)*x374))+(((319.0)*x373)))),-1);
if(!x378.valid){
continue;
}
CheckValue<IkReal> x379 = IKatan2WithCheck(IkReal(((((-1.0)*x376*(py*py)))+(((-1.0)*x372*x376))+((py*x375))+(((-1.0)*x373*x376))+(((-19.24375)*py)))),IkReal(((((-1.0)*x372*x377))+(((-1.0)*x377*(px*px)))+((px*x375))+(((-1.0)*x374*x377))+(((-19.24375)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x379.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x378.value)))+(x379.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x380=IKcos(j0);
IkReal x381=IKsin(j0);
IkReal x382=((1.0)*x380);
IkReal x383=(py*x381);
evalcond[0]=((((-1.0)*py*x382))+((px*x381)));
evalcond[1]=((-0.1595)+(((0.0405)*cj2*sj3))+(((0.0405)*cj3*sj2))+(((-1.0)*px*x382))+(((-1.0)*x383))+(((0.0675)*sj2)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((-0.319)*px*x380))+(((0.0054675)*cj3))+(((-0.319)*x383))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x384=((0.0675)*sj2);
IkReal x385=((0.0405)*cj3*sj2);
IkReal x386=((0.0405)*cj2*sj3);
CheckValue<IkReal> x387 = IKatan2WithCheck(IkReal(((((-0.1595)*py))+((py*x385))+((py*x386))+((py*x384)))),IkReal((((px*x384))+((px*x386))+((px*x385))+(((-0.1595)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x387.valid){
continue;
}
CheckValue<IkReal> x388=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x388.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x387.value)+(((1.5707963267949)*(x388.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x389=IKcos(j0);
IkReal x390=IKsin(j0);
IkReal x391=((1.0)*x389);
IkReal x392=(py*x390);
evalcond[0]=(((px*x390))+(((-1.0)*py*x391)));
evalcond[1]=((-0.1595)+(((-1.0)*x392))+(((0.0405)*cj2*sj3))+(((0.0405)*cj3*sj2))+(((0.0675)*sj2))+(((-1.0)*px*x391)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((-0.319)*x392))+(((-0.319)*px*x389))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x393=pz*pz;
IkReal x394=py*py;
IkReal x395=px*px;
IkReal x396=((5.4675)*cj3);
IkReal x397=((319.0)*sj1);
IkReal x398=((1000.0)*py);
IkReal x399=((1000.0)*px);
IkReal x400=((319.0)*cj1*pz);
CheckValue<IkReal> x401 = IKatan2WithCheck(IkReal((((x395*x398))+(((-1.0)*py*x396))+((x398*(py*py)))+(((-1.0)*py*x400))+(((19.24375)*py))+((x393*x398)))),IkReal(((((-1.0)*px*x400))+((x394*x399))+((x399*(px*px)))+(((-1.0)*px*x396))+(((19.24375)*px))+((x393*x399)))),IKFAST_ATAN2_MAGTHRESH);
if(!x401.valid){
continue;
}
CheckValue<IkReal> x402=IKPowWithIntegerCheck(IKsign((((x395*x397))+((x394*x397)))),-1);
if(!x402.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x401.value)+(((1.5707963267949)*(x402.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x403=IKcos(j0);
IkReal x404=IKsin(j0);
IkReal x405=((0.0405)*sj3);
IkReal x406=((0.0675)*sj2);
IkReal x407=(cj1*cj2);
IkReal x408=((0.0405)*cj3);
IkReal x409=((0.319)*sj1);
IkReal x410=(cj1*pz);
IkReal x411=((1.0)*cj1);
IkReal x412=(px*x403);
IkReal x413=(sj2*x408);
IkReal x414=(py*x404);
evalcond[0]=((((-1.0)*py*x403))+((px*x404)));
evalcond[1]=((-0.1595)+((sj1*x414))+((sj1*x412))+x406+x413+x410+((cj2*x405)));
evalcond[2]=((((0.0675)*cj2))+(((-1.0)*x411*x414))+(((-1.0)*x411*x412))+((pz*sj1))+(((-1.0)*sj2*x405))+((cj2*x408)));
evalcond[3]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x410))+((x409*x412))+((x409*x414))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[4]=(((x407*x408))+(((-1.0)*cj1*sj2*x405))+(((0.1595)*sj1))+(((0.0675)*x407))+(((-1.0)*sj1*x413))+(((-1.0)*sj1*x406))+(((-1.0)*cj2*sj1*x405))+(((-1.0)*x414))+(((-1.0)*x412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x415=(py*sj2);
IkReal x416=((0.0405)*cj3);
IkReal x417=(px*sj2);
IkReal x418=((1.0)*cj1*pz);
IkReal x419=((0.0405)*cj2*sj3);
CheckValue<IkReal> x420=IKPowWithIntegerCheck(IKsign((((sj1*(py*py)))+((sj1*(px*px))))),-1);
if(!x420.valid){
continue;
}
CheckValue<IkReal> x421 = IKatan2WithCheck(IkReal(((((0.1595)*py))+(((-1.0)*x415*x416))+(((-1.0)*py*x418))+(((-1.0)*py*x419))+(((-0.0675)*x415)))),IkReal(((((-1.0)*px*x419))+(((-1.0)*px*x418))+(((0.1595)*px))+(((-1.0)*x416*x417))+(((-0.0675)*x417)))),IKFAST_ATAN2_MAGTHRESH);
if(!x421.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x420.value)))+(x421.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x422=IKcos(j0);
IkReal x423=IKsin(j0);
IkReal x424=((0.0405)*sj3);
IkReal x425=((0.0675)*sj2);
IkReal x426=(cj1*cj2);
IkReal x427=((0.0405)*cj3);
IkReal x428=((0.319)*sj1);
IkReal x429=(cj1*pz);
IkReal x430=((1.0)*cj1);
IkReal x431=(px*x422);
IkReal x432=(sj2*x427);
IkReal x433=(py*x423);
evalcond[0]=((((-1.0)*py*x422))+((px*x423)));
evalcond[1]=((-0.1595)+x429+x425+x432+((cj2*x424))+((sj1*x433))+((sj1*x431)));
evalcond[2]=((((-1.0)*x430*x431))+(((-1.0)*x430*x433))+(((-1.0)*sj2*x424))+(((0.0675)*cj2))+((pz*sj1))+((cj2*x427)));
evalcond[3]=((-0.01924375)+(((-1.0)*(px*px)))+((x428*x431))+((x428*x433))+(((0.319)*x429))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[4]=(((x426*x427))+(((-1.0)*sj1*x432))+(((-1.0)*x431))+(((-1.0)*x433))+(((-1.0)*sj1*x425))+(((0.1595)*sj1))+(((-1.0)*cj2*sj1*x424))+(((0.0675)*x426))+(((-1.0)*cj1*sj2*x424)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x434=((0.0675)*cj2);
IkReal x435=(pz*sj1);
IkReal x436=((0.0405)*sj2*sj3);
IkReal x437=((0.0405)*cj2*cj3);
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign((((cj1*(px*px)))+((cj1*(py*py))))),-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439 = IKatan2WithCheck(IkReal((((py*x437))+((py*x434))+((py*x435))+(((-1.0)*py*x436)))),IkReal((((px*x435))+((px*x434))+((px*x437))+(((-1.0)*px*x436)))),IKFAST_ATAN2_MAGTHRESH);
if(!x439.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x440=IKcos(j0);
IkReal x441=IKsin(j0);
IkReal x442=((0.0405)*sj3);
IkReal x443=((0.0675)*sj2);
IkReal x444=(cj1*cj2);
IkReal x445=((0.0405)*cj3);
IkReal x446=((0.319)*sj1);
IkReal x447=(cj1*pz);
IkReal x448=((1.0)*cj1);
IkReal x449=(px*x440);
IkReal x450=(sj2*x445);
IkReal x451=(py*x441);
evalcond[0]=(((px*x441))+(((-1.0)*py*x440)));
evalcond[1]=((-0.1595)+((sj1*x449))+x447+x443+x450+((sj1*x451))+((cj2*x442)));
evalcond[2]=((((-1.0)*sj2*x442))+(((0.0675)*cj2))+((cj2*x445))+(((-1.0)*x448*x449))+((pz*sj1))+(((-1.0)*x448*x451)));
evalcond[3]=((-0.01924375)+((x446*x449))+(((-1.0)*(px*px)))+(((0.319)*x447))+((x446*x451))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[4]=((((-1.0)*cj2*sj1*x442))+(((-1.0)*cj1*sj2*x442))+(((-1.0)*x449))+(((-1.0)*x451))+(((-1.0)*sj1*x450))+(((0.1595)*sj1))+((x444*x445))+(((0.0675)*x444))+(((-1.0)*sj1*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x453 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x453.valid){
continue;
}
IkReal x452=x453.value;
j0array[0]=((-1.0)*x452);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x452)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[2];
IkReal x454=py*py;
IkReal x455=cj0*cj0;
IkReal x456=(((x454*x455))+(((-1.0)*x455*(px*px)))+(((-1.0)*x454))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0)));
j1eval[0]=x456;
j1eval[1]=IKsign(x456);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x457=(py*sj0);
IkReal x458=(sj2*sj3);
IkReal x459=((1.66666666666667)*cj2);
IkReal x460=((0.0675)*cj2);
IkReal x461=(cj0*px);
IkReal x462=((0.0405)*cj2);
IkReal x463=(pz*sj3);
IkReal x464=(pz*sj2);
IkReal x465=((1.0)*cj2*cj3);
j1eval[0]=((((-1.0)*cj2*x463))+(((-1.0)*x459*x461))+(((3.93827160493827)*pz))+(((-1.0)*x461*x465))+(((-1.0)*x457*x459))+((x458*x461))+(((-1.0)*x457*x465))+(((-1.0)*cj3*x464))+(((-1.66666666666667)*x464))+((x457*x458)));
j1eval[1]=IKsign(((((-0.0405)*cj3*x464))+(((-1.0)*x462*x463))+(((0.1595)*pz))+(((0.0405)*x457*x458))+(((-1.0)*x460*x461))+(((-0.0675)*x464))+(((-1.0)*cj3*x457*x462))+(((-1.0)*cj3*x461*x462))+(((0.0405)*x458*x461))+(((-1.0)*x457*x460))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x466=(cj2*pz);
IkReal x467=(cj0*px);
IkReal x468=(cj2*sj3);
IkReal x469=(py*sj0);
IkReal x470=((0.0405)*cj3);
IkReal x471=(sj2*x467);
IkReal x472=(pz*sj2*sj3);
j1eval[0]=(((x468*x469))+(((1.66666666666667)*x471))+(((1.66666666666667)*sj2*x469))+((cj3*x471))+(((-3.93827160493827)*x467))+(((-3.93827160493827)*x469))+x472+((x467*x468))+((cj3*sj2*x469))+(((-1.0)*cj3*x466))+(((-1.66666666666667)*x466)));
j1eval[1]=IKsign(((((0.0405)*x472))+(((0.0405)*x468*x469))+((x470*x471))+(((-0.0675)*x466))+(((0.0675)*x471))+(((-0.1595)*x467))+(((-0.1595)*x469))+(((0.0675)*sj2*x469))+((sj2*x469*x470))+(((0.0405)*x467*x468))+(((-1.0)*x466*x470))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x473=cj2*cj2;
IkReal x474=cj3*cj3;
IkReal x475=((0.0032805)*cj3);
IkReal x476=(cj2*cj3);
IkReal x477=(cj2*sj2);
IkReal x478=((0.0405)*sj3);
IkReal x479=(py*sj0);
IkReal x480=((0.0405)*cj3);
IkReal x481=((0.0054675)*cj3);
IkReal x482=(cj0*px);
IkReal x483=((1.0)*pz);
IkReal x484=(sj3*x477);
IkReal x485=(sj2*x482);
IkReal x486=(sj3*x473);
IkReal x487=((0.0032805)*x474);
CheckValue<IkReal> x488 = IKatan2WithCheck(IkReal(((-0.0299965)+(((-0.00164025)*x474))+(((-1.0)*x475*x484))+(((-1.0)*x481))+(((0.0215325)*sj2))+(pz*pz)+(((0.0129195)*cj2*sj3))+(((-0.0054675)*x484))+(((0.002916)*x473))+(((0.0129195)*cj3*sj2))+((x473*x481))+((x473*x487)))),IkReal(((((-0.00645975)*x476))+(((0.00645975)*sj2*sj3))+((x475*x486))+(((0.0054675)*sj2*x476))+(((-0.00164025)*cj3*sj3))+(((-1.0)*x479*x483))+(((-0.01076625)*cj2))+(((0.0054675)*x486))+(((-1.0)*x482*x483))+(((0.002916)*x477))+(((-0.00273375)*sj3))+((x477*x487)))),IKFAST_ATAN2_MAGTHRESH);
if(!x488.valid){
continue;
}
CheckValue<IkReal> x489=IKPowWithIntegerCheck(IKsign((((cj2*x478*x479))+((cj2*x478*x482))+(((-0.1595)*x479))+(((0.0675)*x485))+(((-0.0675)*cj2*pz))+((x480*x485))+(((0.0675)*sj2*x479))+(((-0.0405)*pz*x476))+((sj2*x479*x480))+((pz*sj2*x478))+(((-0.1595)*x482)))),-1);
if(!x489.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x488.value)+(((1.5707963267949)*(x489.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x490=IKsin(j1);
IkReal x491=IKcos(j1);
IkReal x492=(cj0*px);
IkReal x493=((0.0405)*cj3);
IkReal x494=((0.0675)*sj2);
IkReal x495=(py*sj0);
IkReal x496=((0.0675)*cj2);
IkReal x497=((0.0405)*cj2*sj3);
IkReal x498=(sj2*x493);
IkReal x499=((1.0)*x491);
IkReal x500=((0.0405)*sj2*sj3);
IkReal x501=(cj2*x491);
IkReal x502=(pz*x491);
IkReal x503=(x490*x495);
evalcond[0]=((-0.1595)+((x490*x492))+x498+x497+x494+x502+x503);
evalcond[1]=(((pz*x490))+(((-1.0)*x495*x499))+(((-1.0)*x500))+x496+((cj2*x493))+(((-1.0)*x492*x499)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((0.319)*x490*x492))+(((-1.0)*(py*py)))+(((0.319)*x503))+(((0.319)*x502)));
evalcond[3]=(((x491*x498))+((x491*x497))+((x491*x494))+((x490*x496))+((cj2*x490*x493))+pz+(((-1.0)*x490*x500))+(((-0.1595)*x491)));
evalcond[4]=(((x491*x496))+(((-1.0)*x490*x498))+(((-1.0)*x490*x497))+(((-1.0)*x490*x494))+((x493*x501))+(((-1.0)*x491*x500))+(((-1.0)*x495))+(((-1.0)*x492))+(((0.1595)*x490)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x504=cj2*cj2;
IkReal x505=cj3*cj3;
IkReal x506=(sj2*sj3);
IkReal x507=((0.0054675)*cj2);
IkReal x508=(cj0*px);
IkReal x509=(cj2*cj3);
IkReal x510=((0.0405)*pz);
IkReal x511=(cj2*sj2);
IkReal x512=(py*sj0);
IkReal x513=((0.0675)*cj2);
IkReal x514=(cj3*sj2);
IkReal x515=(sj3*x504);
IkReal x516=((0.0032805)*x505);
CheckValue<IkReal> x517 = IKatan2WithCheck(IkReal((((x511*x516))+((x507*x514))+(((0.00645975)*x506))+(((-0.00645975)*x509))+((pz*x512))+(((-0.00164025)*cj3*sj3))+(((0.0054675)*x515))+(((-0.01076625)*cj2))+(((0.002916)*x511))+(((0.0032805)*cj3*x515))+((pz*x508))+(((-0.00273375)*sj3)))),IkReal(((-0.00164025)+(((-0.0054675)*cj3*x504))+(((-1.0)*x504*x516))+(((0.00164025)*x505))+(((0.0032805)*x506*x509))+((x506*x507))+(pz*pz)+(((-0.002916)*x504)))),IKFAST_ATAN2_MAGTHRESH);
if(!x517.valid){
continue;
}
CheckValue<IkReal> x518=IKPowWithIntegerCheck(IKsign(((((0.0405)*x506*x512))+(((0.1595)*pz))+(((-0.0405)*x509*x512))+(((-1.0)*x512*x513))+(((0.0405)*x506*x508))+(((-1.0)*cj2*sj3*x510))+(((-0.0405)*x508*x509))+(((-1.0)*x508*x513))+(((-1.0)*x510*x514))+(((-0.0675)*pz*sj2)))),-1);
if(!x518.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x517.value)+(((1.5707963267949)*(x518.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x519=IKsin(j1);
IkReal x520=IKcos(j1);
IkReal x521=(cj0*px);
IkReal x522=((0.0405)*cj3);
IkReal x523=((0.0675)*sj2);
IkReal x524=(py*sj0);
IkReal x525=((0.0675)*cj2);
IkReal x526=((0.0405)*cj2*sj3);
IkReal x527=(sj2*x522);
IkReal x528=((1.0)*x520);
IkReal x529=((0.0405)*sj2*sj3);
IkReal x530=(cj2*x520);
IkReal x531=(pz*x520);
IkReal x532=(x519*x524);
evalcond[0]=((-0.1595)+((x519*x521))+x531+x532+x523+x526+x527);
evalcond[1]=((((-1.0)*x524*x528))+(((-1.0)*x521*x528))+((pz*x519))+(((-1.0)*x529))+x525+((cj2*x522)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x519*x521))+(((0.319)*x532))+(((0.319)*x531))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[3]=(((cj2*x519*x522))+((x519*x525))+pz+((x520*x526))+((x520*x523))+((x520*x527))+(((-0.1595)*x520))+(((-1.0)*x519*x529)));
evalcond[4]=(((x522*x530))+(((-1.0)*x520*x529))+(((-1.0)*x524))+(((-1.0)*x521))+((x520*x525))+(((0.1595)*x519))+(((-1.0)*x519*x527))+(((-1.0)*x519*x523))+(((-1.0)*x519*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x533=py*py;
IkReal x534=cj0*cj0;
IkReal x535=((0.0405)*sj3);
IkReal x536=(cj2*pz);
IkReal x537=(cj0*px);
IkReal x538=(py*sj0);
IkReal x539=((0.0675)*cj2);
IkReal x540=((0.0405)*cj3);
IkReal x541=(pz*sj2);
IkReal x542=(sj2*x537);
IkReal x543=(cj2*x540);
CheckValue<IkReal> x544 = IKatan2WithCheck(IkReal(((((0.0675)*sj2*x538))+((cj2*x535*x537))+((cj2*x535*x538))+((x540*x542))+((x536*x540))+(((-1.0)*x535*x541))+(((-0.1595)*x537))+(((-0.1595)*x538))+(((0.0675)*x536))+((sj2*x538*x540))+(((0.0675)*x542)))),IkReal(((((-1.0)*x537*x543))+(((-1.0)*x537*x539))+((sj2*x535*x538))+(((-1.0)*x538*x539))+(((-1.0)*x538*x543))+((x540*x541))+((x535*x542))+((x535*x536))+(((-0.1595)*pz))+(((0.0675)*x541)))),IKFAST_ATAN2_MAGTHRESH);
if(!x544.valid){
continue;
}
CheckValue<IkReal> x545=IKPowWithIntegerCheck(IKsign(((((-2.0)*x537*x538))+(((-1.0)*x533))+(((-1.0)*(pz*pz)))+((x533*x534))+(((-1.0)*x534*(px*px))))),-1);
if(!x545.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x544.value)+(((1.5707963267949)*(x545.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x546=IKsin(j1);
IkReal x547=IKcos(j1);
IkReal x548=(cj0*px);
IkReal x549=((0.0405)*cj3);
IkReal x550=((0.0675)*sj2);
IkReal x551=(py*sj0);
IkReal x552=((0.0675)*cj2);
IkReal x553=((0.0405)*cj2*sj3);
IkReal x554=(sj2*x549);
IkReal x555=((1.0)*x547);
IkReal x556=((0.0405)*sj2*sj3);
IkReal x557=(cj2*x547);
IkReal x558=(pz*x547);
IkReal x559=(x546*x551);
evalcond[0]=((-0.1595)+x559+x558+x553+x550+x554+((x546*x548)));
evalcond[1]=((((-1.0)*x551*x555))+(((-1.0)*x548*x555))+(((-1.0)*x556))+x552+((cj2*x549))+((pz*x546)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x558))+(((0.319)*x559))+(((0.319)*x546*x548))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[3]=(((x547*x550))+((x547*x553))+((x547*x554))+pz+(((-0.1595)*x547))+((cj2*x546*x549))+((x546*x552))+(((-1.0)*x546*x556)));
evalcond[4]=((((-1.0)*x551))+(((-1.0)*x548))+(((-1.0)*x547*x556))+((x547*x552))+((x549*x557))+(((-1.0)*x546*x553))+(((-1.0)*x546*x550))+(((-1.0)*x546*x554))+(((0.1595)*x546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x561 = IKatan2WithCheck(IkReal(((-1.0)*py)),IkReal(px),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
IkReal x560=x561.value;
j0array[0]=((-1.0)*x560);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x560)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2eval[2];
j2eval[0]=((IKabs(sj3))+(((77.402376252951)*(IKabs(((-0.0215325)+(((-0.0129195)*cj3))))))));
j2eval[1]=((2.77777777777778)+(sj3*sj3)+(cj3*cj3)+(((3.33333333333333)*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x562=(py*sj0);
IkReal x563=(cj0*px);
j1eval[0]=((((2.0)*x562*x563))+(pz*pz)+(x563*x563)+(x562*x562));
j1eval[1]=((((3.13479623824451)*(IKabs(((((0.319)*x562))+(((0.319)*x563)))))))+(IKabs(pz)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x564=pz*pz;
IkReal x565=((((0.319)*py*sj0))+(((0.319)*cj0*px)));
CheckValue<IkReal> x568 = IKatan2WithCheck(IkReal(((0.319)*pz)),IkReal(x565),IKFAST_ATAN2_MAGTHRESH);
if(!x568.valid){
continue;
}
IkReal x566=((1.0)*(x568.value));
if((((x565*x565)+(((0.101761)*x564)))) < -0.00001)
continue;
CheckValue<IkReal> x569=IKPowWithIntegerCheck(IKabs(IKsqrt(((x565*x565)+(((0.101761)*x564))))),-1);
if(!x569.valid){
continue;
}
if( (((x569.value)*(((-0.01924375)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*x564))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x569.value)*(((-0.01924375)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*x564))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x567=IKasin(((x569.value)*(((-0.01924375)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*x564))+(((-1.0)*(py*py)))))));
j1array[0]=((((-1.0)*x567))+(((-1.0)*x566)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x567+(((-1.0)*x566)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[2];
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((24786.0)+(((21870.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x570=(cj1*cj3);
j2eval[0]=(x570+(((1.13333333333333)*cj1)));
j2eval[1]=IKsign(((((12.393)*cj1))+(((10.935)*x570))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x571=(cj3*sj1);
j2eval[0]=((((1.13333333333333)*sj1))+x571);
j2eval[1]=IKsign(((((12.393)*sj1))+(((10.935)*x571))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x572=((162000.0)*sj3);
IkReal x573=(py*sj0);
IkReal x574=(cj0*px);
IkReal x575=((162000.0)*cj3);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((24786.0)+(((21870.0)*cj3))));
j2eval[2]=((IKabs(((43065.0)+(((-270000.0)*pz))+(((25839.0)*cj3))+(((-1.0)*pz*x575))+(((-1.0)*x572*x574))+(((-1.0)*x572*x573)))))+(IKabs((((x574*x575))+((x573*x575))+(((-1.0)*pz*x572))+(((270000.0)*x573))+(((270000.0)*x574))+(((25839.0)*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=1.0;
j1=0;
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((7906734.0)+(((6976530.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x576=px*px;
IkReal x577=pz*pz;
IkReal x578=py*py;
IkReal x579=((162000000.0)*sj3);
IkReal x580=(py*sj0);
IkReal x581=((51678000.0)*cj3);
IkReal x582=(cj0*px);
IkReal x583=((162000000.0)*cj3);
IkReal x584=((51678000.0)*sj3);
CheckValue<IkReal> x585=IKPowWithIntegerCheck(IKsign(((7906734.0)+(((6976530.0)*cj3)))),-1);
if(!x585.valid){
continue;
}
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal(((8541922.5)+(((-1.0)*x580*x584))+(((-1.0)*x582*x584))+(((6601378.5)*cj3))+(((-1.0)*x578*x583))+(((-1.0)*x577*x583))+(((-270000000.0)*x576))+(((-270000000.0)*x577))+(((-270000000.0)*x578))+(((-1.0)*x576*x583))+(((885735.0)*(cj3*cj3))))),IkReal(((((-1.0)*x578*x579))+((x581*x582))+((x580*x581))+(((-1.0)*x577*x579))+(((-1.0)*x576*x579))+(((885735.0)*cj3*sj3))+(((86130000.0)*x580))+(((86130000.0)*x582))+(((5125153.5)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x585.value)))+(x586.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x587=IKsin(j2);
IkReal x588=IKcos(j2);
IkReal x589=(cj3*x587);
IkReal x590=(sj3*x588);
evalcond[0]=((-0.1595)+(((0.0405)*x590))+(((0.0675)*x587))+(((0.0405)*x589))+pz);
evalcond[1]=((((-0.0405)*sj3*x587))+(((0.0405)*cj3*x588))+(((0.0675)*x588))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0129195)*x590))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0129195)*x589))+(((-0.0215325)*x587))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x591=((162000.0)*sj3);
IkReal x592=(py*sj0);
IkReal x593=(cj0*px);
IkReal x594=((162000.0)*cj3);
CheckValue<IkReal> x595=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x595.valid){
continue;
}
CheckValue<IkReal> x596 = IKatan2WithCheck(IkReal(((43065.0)+(((-270000.0)*pz))+(((25839.0)*cj3))+(((-1.0)*pz*x594))+(((-1.0)*x591*x593))+(((-1.0)*x591*x592)))),IkReal(((((-1.0)*pz*x591))+(((270000.0)*x592))+(((270000.0)*x593))+(((25839.0)*sj3))+((x593*x594))+((x592*x594)))),IKFAST_ATAN2_MAGTHRESH);
if(!x596.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x595.value)))+(x596.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x597=IKsin(j2);
IkReal x598=IKcos(j2);
IkReal x599=(cj3*x597);
IkReal x600=(sj3*x598);
evalcond[0]=((-0.1595)+(((0.0405)*x600))+(((0.0405)*x599))+pz+(((0.0675)*x597)));
evalcond[1]=((((-0.0405)*sj3*x597))+(((-1.0)*py*sj0))+(((0.0675)*x598))+(((-1.0)*cj0*px))+(((0.0405)*cj3*x598)));
evalcond[2]=((0.03163675)+(((-0.0215325)*x597))+(((-1.0)*(px*px)))+(((-0.0129195)*x599))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0129195)*x600))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x601=((162000.0)*sj3);
IkReal x602=(py*sj0);
IkReal x603=((162000.0)*cj3);
IkReal x604=(cj0*px);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=((IKabs(((((-1.0)*x602*x603))+(((-1.0)*x603*x604))+(((25839.0)*sj3))+((pz*x601))+(((-270000.0)*x604))+(((-270000.0)*x602)))))+(IKabs(((43065.0)+((x601*x604))+((x601*x602))+(((25839.0)*cj3))+(((270000.0)*pz))+((pz*x603))))));
j2eval[2]=IKsign(((24786.0)+(((21870.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((7906734.0)+(((6976530.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x605=px*px;
IkReal x606=pz*pz;
IkReal x607=py*py;
IkReal x608=((162000000.0)*sj3);
IkReal x609=(py*sj0);
IkReal x610=((51678000.0)*cj3);
IkReal x611=(cj0*px);
IkReal x612=((162000000.0)*cj3);
IkReal x613=((51678000.0)*sj3);
CheckValue<IkReal> x614=IKPowWithIntegerCheck(IKsign(((7906734.0)+(((6976530.0)*cj3)))),-1);
if(!x614.valid){
continue;
}
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal(((8541922.5)+(((6601378.5)*cj3))+(((-270000000.0)*x605))+(((-270000000.0)*x606))+(((-270000000.0)*x607))+((x611*x613))+(((-1.0)*x605*x612))+(((-1.0)*x606*x612))+(((-1.0)*x607*x612))+((x609*x613))+(((885735.0)*(cj3*cj3))))),IkReal(((((-1.0)*x610*x611))+(((-1.0)*x609*x610))+(((-1.0)*x605*x608))+(((885735.0)*cj3*sj3))+(((-86130000.0)*x611))+(((-1.0)*x606*x608))+(((-86130000.0)*x609))+(((-1.0)*x607*x608))+(((5125153.5)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x614.value)))+(x615.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x616=IKsin(j2);
IkReal x617=IKcos(j2);
IkReal x618=(cj3*x616);
IkReal x619=(sj3*x617);
evalcond[0]=((-0.1595)+(((0.0675)*x616))+(((0.0405)*x619))+(((0.0405)*x618))+(((-1.0)*pz)));
evalcond[1]=((((0.0675)*x617))+(((-0.0405)*sj3*x616))+(((0.0405)*cj3*x617))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0215325)*x616))+(((-0.0129195)*x618))+(((-0.0129195)*x619))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x620=((162000.0)*sj3);
IkReal x621=(py*sj0);
IkReal x622=((162000.0)*cj3);
IkReal x623=(cj0*px);
CheckValue<IkReal> x624=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x624.valid){
continue;
}
CheckValue<IkReal> x625 = IKatan2WithCheck(IkReal(((43065.0)+((pz*x622))+(((25839.0)*cj3))+(((270000.0)*pz))+((x620*x623))+((x620*x621)))),IkReal((((pz*x620))+(((-1.0)*x621*x622))+(((-1.0)*x622*x623))+(((-270000.0)*x623))+(((-270000.0)*x621))+(((25839.0)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x625.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x624.value)))+(x625.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x626=IKsin(j2);
IkReal x627=IKcos(j2);
IkReal x628=(cj3*x626);
IkReal x629=(sj3*x627);
evalcond[0]=((-0.1595)+(((-1.0)*pz))+(((0.0675)*x626))+(((0.0405)*x628))+(((0.0405)*x629)));
evalcond[1]=((((0.0405)*cj3*x627))+(((-0.0405)*sj3*x626))+(((0.0675)*x627))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0215325)*x626))+(((-0.0129195)*x629))+(((-0.0129195)*x628))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x630=((162000.0)*sj3);
IkReal x631=(py*sj0);
IkReal x632=(cj0*px);
IkReal x633=((162000.0)*cj3);
j2eval[0]=((1.13333333333333)+cj3);
j2eval[1]=IKsign(((24786.0)+(((21870.0)*cj3))));
j2eval[2]=((IKabs(((((-1.0)*pz*x633))+(((-270000.0)*pz))+(((-1.0)*x630*x632))+(((-1.0)*x630*x631))+(((25839.0)*sj3)))))+(IKabs(((43065.0)+(((-1.0)*x631*x633))+((pz*x630))+(((25839.0)*cj3))+(((-270000.0)*x631))+(((-270000.0)*x632))+(((-1.0)*x632*x633))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
j2eval[0]=((-1.13333333333333)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-7906734.0)+(((-6976530.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x634=px*px;
IkReal x635=pz*pz;
IkReal x636=py*py;
IkReal x637=((162000000.0)*sj3);
IkReal x638=((162000000.0)*cj3);
IkReal x639=((51678000.0)*pz);
CheckValue<IkReal> x640 = IKatan2WithCheck(IkReal(((-8541922.5)+((x634*x638))+((x635*x638))+((x636*x638))+(((270000000.0)*x636))+(((270000000.0)*x634))+(((270000000.0)*x635))+(((-6601378.5)*cj3))+(((-1.0)*sj3*x639))+(((-885735.0)*(cj3*cj3))))),IkReal((((cj3*x639))+((x634*x637))+((x635*x637))+((x636*x637))+(((-885735.0)*cj3*sj3))+(((86130000.0)*pz))+(((-5125153.5)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x640.valid){
continue;
}
CheckValue<IkReal> x641=IKPowWithIntegerCheck(IKsign(((-7906734.0)+(((-6976530.0)*cj3)))),-1);
if(!x641.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x640.value)+(((1.5707963267949)*(x641.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x642=IKcos(j2);
IkReal x643=IKsin(j2);
IkReal x644=(cj3*x643);
IkReal x645=(sj3*x642);
evalcond[0]=((((-0.0405)*sj3*x643))+(((0.0675)*x642))+(((0.0405)*cj3*x642))+pz);
evalcond[1]=((-0.1595)+(((0.0675)*x643))+((cj0*px))+((py*sj0))+(((0.0405)*x644))+(((0.0405)*x645)));
evalcond[2]=((0.03163675)+(((-0.0129195)*x645))+(((-0.0129195)*x644))+(((-1.0)*(px*px)))+(((-0.0215325)*x643))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x646=((162000.0)*sj3);
IkReal x647=(py*sj0);
IkReal x648=(cj0*px);
IkReal x649=((162000.0)*cj3);
CheckValue<IkReal> x650=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x650.valid){
continue;
}
CheckValue<IkReal> x651 = IKatan2WithCheck(IkReal(((43065.0)+(((-270000.0)*x647))+(((-270000.0)*x648))+(((-1.0)*x647*x649))+(((25839.0)*cj3))+((pz*x646))+(((-1.0)*x648*x649)))),IkReal(((((-270000.0)*pz))+(((-1.0)*x646*x648))+(((-1.0)*x646*x647))+(((25839.0)*sj3))+(((-1.0)*pz*x649)))),IKFAST_ATAN2_MAGTHRESH);
if(!x651.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x650.value)))+(x651.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x652=IKcos(j2);
IkReal x653=IKsin(j2);
IkReal x654=(cj3*x653);
IkReal x655=(sj3*x652);
evalcond[0]=((((0.0675)*x652))+pz+(((0.0405)*cj3*x652))+(((-0.0405)*sj3*x653)));
evalcond[1]=((-0.1595)+(((0.0675)*x653))+(((0.0405)*x655))+(((0.0405)*x654))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0129195)*x654))+(((-0.0129195)*x655))+(((-0.0215325)*x653))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x656=((162000.0)*sj3);
IkReal x657=(py*sj0);
IkReal x658=(cj0*px);
IkReal x659=((162000.0)*cj3);
j2eval[0]=((-1.13333333333333)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-24786.0)+(((-21870.0)*cj3))));
j2eval[2]=((IKabs(((-43065.0)+(((-270000.0)*x657))+(((-270000.0)*x658))+(((-1.0)*x657*x659))+((pz*x656))+(((-25839.0)*cj3))+(((-1.0)*x658*x659)))))+(IKabs(((((-270000.0)*pz))+(((-1.0)*x656*x657))+(((-1.0)*x656*x658))+(((-1.0)*pz*x659))+(((-25839.0)*sj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
j2eval[0]=((-1.13333333333333)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-7906734.0)+(((-6976530.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x660=px*px;
IkReal x661=pz*pz;
IkReal x662=py*py;
IkReal x663=((162000000.0)*sj3);
IkReal x664=((162000000.0)*cj3);
IkReal x665=((51678000.0)*pz);
CheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(((-8541922.5)+((x662*x664))+((x660*x664))+(((-6601378.5)*cj3))+((x661*x664))+((sj3*x665))+(((270000000.0)*x661))+(((270000000.0)*x660))+(((270000000.0)*x662))+(((-885735.0)*(cj3*cj3))))),IkReal(((((-86130000.0)*pz))+(((-1.0)*cj3*x665))+((x662*x663))+(((-885735.0)*cj3*sj3))+((x660*x663))+((x661*x663))+(((-5125153.5)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x666.valid){
continue;
}
CheckValue<IkReal> x667=IKPowWithIntegerCheck(IKsign(((-7906734.0)+(((-6976530.0)*cj3)))),-1);
if(!x667.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x666.value)+(((1.5707963267949)*(x667.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x668=IKcos(j2);
IkReal x669=IKsin(j2);
IkReal x670=(cj3*x669);
IkReal x671=(sj3*x668);
evalcond[0]=((((0.0405)*cj3*x668))+(((-1.0)*pz))+(((0.0675)*x668))+(((-0.0405)*sj3*x669)));
evalcond[1]=((-0.1595)+(((0.0405)*x671))+(((0.0405)*x670))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))+(((0.0675)*x669)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0129195)*x670))+(((-0.0129195)*x671))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0215325)*x669))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x672=((162000.0)*sj3);
IkReal x673=(py*sj0);
IkReal x674=(cj0*px);
IkReal x675=((162000.0)*cj3);
CheckValue<IkReal> x676=IKPowWithIntegerCheck(IKsign(((-24786.0)+(((-21870.0)*cj3)))),-1);
if(!x676.valid){
continue;
}
CheckValue<IkReal> x677 = IKatan2WithCheck(IkReal(((-43065.0)+((pz*x672))+(((-25839.0)*cj3))+(((-270000.0)*x673))+(((-270000.0)*x674))+(((-1.0)*x674*x675))+(((-1.0)*x673*x675)))),IkReal(((((-270000.0)*pz))+(((-1.0)*pz*x675))+(((-1.0)*x672*x674))+(((-1.0)*x672*x673))+(((-25839.0)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x677.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x676.value)))+(x677.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x678=IKcos(j2);
IkReal x679=IKsin(j2);
IkReal x680=(cj3*x679);
IkReal x681=(sj3*x678);
evalcond[0]=((((0.0405)*cj3*x678))+(((-0.0405)*sj3*x679))+(((-1.0)*pz))+(((0.0675)*x678)));
evalcond[1]=((-0.1595)+(((0.0405)*x680))+(((0.0405)*x681))+(((-1.0)*py*sj0))+(((0.0675)*x679))+(((-1.0)*cj0*px)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0215325)*x679))+(((-0.0129195)*x681))+(((-0.0129195)*x680))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x682=cj1*cj1;
IkReal x683=((81.0)*sj3);
IkReal x684=(cj0*px);
IkReal x685=(cj1*sj1);
IkReal x686=((81.0)*cj3);
IkReal x687=(cj3*sj1);
IkReal x688=((135.0)*pz);
IkReal x689=(py*sj0);
IkReal x690=(pz*x682);
IkReal x691=((135.0)*x689);
IkReal x692=(x685*x689);
IkReal x693=(x682*x684);
CheckValue<IkReal> x694=IKPowWithIntegerCheck(IKsign(((((12.393)*sj1))+(((10.935)*x687)))),-1);
if(!x694.valid){
continue;
}
CheckValue<IkReal> x695 = IKatan2WithCheck(IkReal(((((21.5325)*sj1))+(((-1.0)*pz*x685*x686))+((x682*x691))+(((-1.0)*x685*x688))+((x686*x693))+(((12.9195)*x687))+(((-1.0)*x683*x692))+(((-1.0)*x683*x690))+(((-135.0)*x684))+(((-1.0)*x686*x689))+(((-1.0)*x684*x686))+((x682*x686*x689))+(((-1.0)*x691))+(((135.0)*x693))+(((-1.0)*x683*x684*x685))+((pz*x683)))),IkReal(((((-1.0)*x688))+((x682*x688))+(((-1.0)*pz*x683*x685))+((x686*x690))+((x686*x692))+((x682*x683*x689))+(((-1.0)*x683*x689))+(((-1.0)*x683*x684))+(((12.9195)*sj1*sj3))+((x685*x691))+(((135.0)*x684*x685))+((x684*x685*x686))+(((-1.0)*pz*x686))+((x683*x693)))),IKFAST_ATAN2_MAGTHRESH);
if(!x695.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x694.value)))+(x695.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x696=IKsin(j2);
IkReal x697=IKcos(j2);
IkReal x698=(cj0*px);
IkReal x699=((0.0405)*cj1);
IkReal x700=(py*sj0);
IkReal x701=((0.0675)*cj1);
IkReal x702=((0.0405)*sj1);
IkReal x703=((1.0)*cj1);
IkReal x704=(sj3*x697);
IkReal x705=(cj3*x696);
IkReal x706=(sj3*x696);
IkReal x707=(cj3*x697);
IkReal x708=((0.0675)*x697);
IkReal x709=((0.0675)*x696);
evalcond[0]=((-0.1595)+(((0.0405)*x705))+(((0.0405)*x704))+((sj1*x698))+((cj1*pz))+((sj1*x700))+x709);
evalcond[1]=((((0.0405)*x707))+x708+(((-1.0)*x698*x703))+((pz*sj1))+(((-0.0405)*x706))+(((-1.0)*x700*x703)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0129195)*x704))+(((-0.0129195)*x705))+(((-0.0215325)*x696))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[3]=(((x702*x707))+(((-1.0)*x702*x706))+(((-0.1595)*cj1))+pz+((x696*x701))+((sj1*x708))+((x699*x704))+((x699*x705)));
evalcond[4]=((((-1.0)*x702*x704))+(((-1.0)*x702*x705))+(((-1.0)*x700))+(((0.1595)*sj1))+((x697*x701))+(((-1.0)*x699*x706))+(((-1.0)*sj1*x709))+((x699*x707))+(((-1.0)*x698)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x710=cj1*cj1;
IkReal x711=((81.0)*sj3);
IkReal x712=(cj1*cj3);
IkReal x713=(cj0*px);
IkReal x714=(cj1*sj1);
IkReal x715=(py*sj0);
IkReal x716=((81.0)*sj1);
IkReal x717=((135.0)*x710);
IkReal x718=(x714*x715);
IkReal x719=((81.0)*cj3*x710);
CheckValue<IkReal> x720 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x717))+(((-1.0)*pz*x719))+(((-135.0)*x718))+(((-135.0)*x713*x714))+(((21.5325)*cj1))+((pz*x711*x714))+(((-1.0)*x710*x711*x715))+(((-1.0)*x710*x711*x713))+(((12.9195)*x712))+(((-1.0)*x712*x715*x716))+(((-1.0)*x712*x713*x716)))),IkReal((((x715*x717))+((x715*x719))+(((-1.0)*x711*x718))+(((12.9195)*cj1*sj3))+(((-135.0)*pz*x714))+(((-1.0)*x711*x713*x714))+(((-1.0)*pz*x710*x711))+(((-1.0)*pz*x712*x716))+((x713*x719))+((x713*x717)))),IKFAST_ATAN2_MAGTHRESH);
if(!x720.valid){
continue;
}
CheckValue<IkReal> x721=IKPowWithIntegerCheck(IKsign(((((12.393)*cj1))+(((10.935)*x712)))),-1);
if(!x721.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x720.value)+(((1.5707963267949)*(x721.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x722=IKsin(j2);
IkReal x723=IKcos(j2);
IkReal x724=(cj0*px);
IkReal x725=((0.0405)*cj1);
IkReal x726=(py*sj0);
IkReal x727=((0.0675)*cj1);
IkReal x728=((0.0405)*sj1);
IkReal x729=((1.0)*cj1);
IkReal x730=(sj3*x723);
IkReal x731=(cj3*x722);
IkReal x732=(sj3*x722);
IkReal x733=(cj3*x723);
IkReal x734=((0.0675)*x723);
IkReal x735=((0.0675)*x722);
evalcond[0]=((-0.1595)+((cj1*pz))+x735+((sj1*x726))+((sj1*x724))+(((0.0405)*x730))+(((0.0405)*x731)));
evalcond[1]=((((-1.0)*x724*x729))+(((-1.0)*x726*x729))+x734+((pz*sj1))+(((-0.0405)*x732))+(((0.0405)*x733)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((-0.0129195)*x731))+(((-0.0129195)*x730))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-0.0215325)*x722))+(((-1.0)*(py*py))));
evalcond[3]=(((x728*x733))+(((-0.1595)*cj1))+((x722*x727))+pz+((x725*x730))+((x725*x731))+((sj1*x734))+(((-1.0)*x728*x732)));
evalcond[4]=(((x723*x727))+(((-1.0)*x725*x732))+(((-1.0)*x726))+(((-1.0)*x724))+(((0.1595)*sj1))+(((-1.0)*sj1*x735))+((x725*x733))+(((-1.0)*x728*x731))+(((-1.0)*x728*x730)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x736=((162000.0)*cj1);
IkReal x737=(py*sj0);
IkReal x738=(pz*sj3);
IkReal x739=((162000.0)*sj1);
IkReal x740=(cj0*px);
IkReal x741=((270000.0)*sj1);
IkReal x742=(cj3*pz);
IkReal x743=((270000.0)*cj1);
CheckValue<IkReal> x744=IKPowWithIntegerCheck(IKsign(((24786.0)+(((21870.0)*cj3)))),-1);
if(!x744.valid){
continue;
}
CheckValue<IkReal> x745 = IKatan2WithCheck(IkReal(((43065.0)+(((-1.0)*sj3*x736*x740))+(((-1.0)*x737*x741))+(((25839.0)*cj3))+(((-1.0)*sj3*x736*x737))+(((-1.0)*cj3*x739*x740))+(((-1.0)*pz*x743))+(((-1.0)*x740*x741))+(((-1.0)*cj3*x737*x739))+((x738*x739))+(((-1.0)*x736*x742)))),IkReal((((cj3*x736*x737))+(((-1.0)*x736*x738))+((cj3*x736*x740))+((x740*x743))+(((-1.0)*sj3*x739*x740))+(((-1.0)*pz*x741))+((x737*x743))+(((25839.0)*sj3))+(((-1.0)*x739*x742))+(((-1.0)*sj3*x737*x739)))),IKFAST_ATAN2_MAGTHRESH);
if(!x745.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x744.value)))+(x745.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x746=IKsin(j2);
IkReal x747=IKcos(j2);
IkReal x748=(cj0*px);
IkReal x749=((0.0405)*cj1);
IkReal x750=(py*sj0);
IkReal x751=((0.0675)*cj1);
IkReal x752=((0.0405)*sj1);
IkReal x753=((1.0)*cj1);
IkReal x754=(sj3*x747);
IkReal x755=(cj3*x746);
IkReal x756=(sj3*x746);
IkReal x757=(cj3*x747);
IkReal x758=((0.0675)*x747);
IkReal x759=((0.0675)*x746);
evalcond[0]=((-0.1595)+(((0.0405)*x754))+(((0.0405)*x755))+((sj1*x750))+((cj1*pz))+((sj1*x748))+x759);
evalcond[1]=((((-1.0)*x750*x753))+(((0.0405)*x757))+(((-0.0405)*x756))+x758+((pz*sj1))+(((-1.0)*x748*x753)));
evalcond[2]=((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-0.0129195)*x755))+(((-0.0129195)*x754))+(((-0.0215325)*x746)));
evalcond[3]=(((x752*x757))+(((-0.1595)*cj1))+((sj1*x758))+((x746*x751))+pz+(((-1.0)*x752*x756))+((x749*x754))+((x749*x755)));
evalcond[4]=((((-1.0)*sj1*x759))+((x747*x751))+(((0.1595)*sj1))+(((-1.0)*x750))+(((-1.0)*x748))+(((-1.0)*x752*x755))+(((-1.0)*x752*x754))+(((-1.0)*x749*x756))+((x749*x757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x760=((-0.0215325)+(((-0.0129195)*cj3)));
CheckValue<IkReal> x763 = IKatan2WithCheck(IkReal(((-0.0129195)*sj3)),IkReal(x760),IKFAST_ATAN2_MAGTHRESH);
if(!x763.valid){
continue;
}
IkReal x761=((1.0)*(x763.value));
if((((((0.00016691348025)*(sj3*sj3)))+(x760*x760))) < -0.00001)
continue;
CheckValue<IkReal> x764=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.00016691348025)*(sj3*sj3)))+(x760*x760)))),-1);
if(!x764.valid){
continue;
}
if( (((x764.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x764.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x762=IKasin(((x764.value)*(((0.03163675)+(((-1.0)*(px*px)))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x761))+(((-1.0)*x762)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x761))+x762);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[2];
IkReal x765=py*py;
IkReal x766=cj0*cj0;
IkReal x767=((((-1.0)*x765))+((x765*x766))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0))+(((-1.0)*x766*(px*px))));
j1eval[0]=x767;
j1eval[1]=IKsign(x767);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x768=(py*sj0);
IkReal x769=(sj2*sj3);
IkReal x770=((1.66666666666667)*cj2);
IkReal x771=((0.0675)*cj2);
IkReal x772=(cj0*px);
IkReal x773=((0.0405)*cj2);
IkReal x774=(pz*sj3);
IkReal x775=(pz*sj2);
IkReal x776=((1.0)*cj2*cj3);
j1eval[0]=((((-1.0)*x768*x770))+(((-1.0)*x768*x776))+(((-1.0)*cj3*x775))+((x768*x769))+(((-1.66666666666667)*x775))+((x769*x772))+(((-1.0)*cj2*x774))+(((-1.0)*x772*x776))+(((3.93827160493827)*pz))+(((-1.0)*x770*x772)));
j1eval[1]=IKsign(((((-1.0)*cj3*x772*x773))+(((-1.0)*x768*x771))+(((-0.0675)*x775))+(((0.1595)*pz))+(((0.0405)*x768*x769))+(((-1.0)*x771*x772))+(((-1.0)*cj3*x768*x773))+(((0.0405)*x769*x772))+(((-1.0)*x773*x774))+(((-0.0405)*cj3*x775))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x777=(cj2*pz);
IkReal x778=(cj0*px);
IkReal x779=(cj2*sj3);
IkReal x780=(py*sj0);
IkReal x781=((0.0405)*cj3);
IkReal x782=(sj2*x778);
IkReal x783=(pz*sj2*sj3);
j1eval[0]=((((-3.93827160493827)*x780))+(((-3.93827160493827)*x778))+(((-1.0)*cj3*x777))+(((1.66666666666667)*sj2*x780))+(((-1.66666666666667)*x777))+(((1.66666666666667)*x782))+((x779*x780))+((x778*x779))+x783+((cj3*x782))+((cj3*sj2*x780)));
j1eval[1]=IKsign((((x781*x782))+(((-0.1595)*x778))+(((0.0405)*x783))+(((0.0405)*x779*x780))+(((-0.0675)*x777))+(((0.0675)*sj2*x780))+(((-1.0)*x777*x781))+(((0.0405)*x778*x779))+(((0.0675)*x782))+(((-0.1595)*x780))+((sj2*x780*x781))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x784=cj2*cj2;
IkReal x785=cj3*cj3;
IkReal x786=((0.0032805)*cj3);
IkReal x787=(cj2*cj3);
IkReal x788=(cj2*sj2);
IkReal x789=((0.0405)*sj3);
IkReal x790=(py*sj0);
IkReal x791=((0.0405)*cj3);
IkReal x792=((0.0054675)*cj3);
IkReal x793=(cj0*px);
IkReal x794=((1.0)*pz);
IkReal x795=(sj3*x788);
IkReal x796=(sj2*x793);
IkReal x797=(sj3*x784);
IkReal x798=((0.0032805)*x785);
CheckValue<IkReal> x799=IKPowWithIntegerCheck(IKsign((((cj2*x789*x790))+((cj2*x789*x793))+(((-0.0405)*pz*x787))+((pz*sj2*x789))+((sj2*x790*x791))+(((-0.0675)*cj2*pz))+(((0.0675)*sj2*x790))+(((0.0675)*x796))+(((-0.1595)*x793))+(((-0.1595)*x790))+((x791*x796)))),-1);
if(!x799.valid){
continue;
}
CheckValue<IkReal> x800 = IKatan2WithCheck(IkReal(((-0.0299965)+(((-0.00164025)*x785))+(((-1.0)*x792))+(((0.0215325)*sj2))+(((0.002916)*x784))+(pz*pz)+((x784*x798))+((x784*x792))+(((0.0129195)*cj2*sj3))+(((-1.0)*x786*x795))+(((-0.0054675)*x795))+(((0.0129195)*cj3*sj2)))),IkReal((((x786*x797))+(((0.00645975)*sj2*sj3))+(((0.002916)*x788))+(((0.0054675)*sj2*x787))+(((-1.0)*x793*x794))+((x788*x798))+(((-0.00164025)*cj3*sj3))+(((-1.0)*x790*x794))+(((-0.01076625)*cj2))+(((0.0054675)*x797))+(((-0.00273375)*sj3))+(((-0.00645975)*x787)))),IKFAST_ATAN2_MAGTHRESH);
if(!x800.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x799.value)))+(x800.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x801=IKsin(j1);
IkReal x802=IKcos(j1);
IkReal x803=(cj0*px);
IkReal x804=((0.0405)*cj3);
IkReal x805=((0.0675)*sj2);
IkReal x806=(py*sj0);
IkReal x807=((0.0675)*cj2);
IkReal x808=((0.0405)*cj2*sj3);
IkReal x809=(sj2*x804);
IkReal x810=((1.0)*x802);
IkReal x811=((0.0405)*sj2*sj3);
IkReal x812=(cj2*x802);
IkReal x813=(pz*x802);
IkReal x814=(x801*x806);
evalcond[0]=((-0.1595)+((x801*x803))+x814+x813+x809+x808+x805);
evalcond[1]=((((-1.0)*x803*x810))+(((-1.0)*x811))+((cj2*x804))+((pz*x801))+x807+(((-1.0)*x806*x810)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x813))+(((0.319)*x814))+(((0.0054675)*cj3))+(((0.319)*x801*x803))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[3]=((((-1.0)*x801*x811))+((cj2*x801*x804))+pz+((x801*x807))+((x802*x808))+((x802*x809))+((x802*x805))+(((-0.1595)*x802)));
evalcond[4]=((((-1.0)*x803))+(((-1.0)*x806))+(((-1.0)*x802*x811))+((x804*x812))+(((0.1595)*x801))+(((-1.0)*x801*x805))+(((-1.0)*x801*x808))+(((-1.0)*x801*x809))+((x802*x807)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x815=cj2*cj2;
IkReal x816=cj3*cj3;
IkReal x817=(sj2*sj3);
IkReal x818=((0.0054675)*cj2);
IkReal x819=(cj0*px);
IkReal x820=(cj2*cj3);
IkReal x821=((0.0405)*pz);
IkReal x822=(cj2*sj2);
IkReal x823=(py*sj0);
IkReal x824=((0.0675)*cj2);
IkReal x825=(cj3*sj2);
IkReal x826=(sj3*x815);
IkReal x827=((0.0032805)*x816);
CheckValue<IkReal> x828 = IKatan2WithCheck(IkReal((((pz*x823))+(((0.00645975)*x817))+(((0.0054675)*x826))+((pz*x819))+(((0.0032805)*cj3*x826))+(((-0.00164025)*cj3*sj3))+((x822*x827))+((x818*x825))+(((-0.01076625)*cj2))+(((-0.00645975)*x820))+(((0.002916)*x822))+(((-0.00273375)*sj3)))),IkReal(((-0.00164025)+(((0.0032805)*x817*x820))+(((0.00164025)*x816))+(((-1.0)*x815*x827))+(((-0.002916)*x815))+(pz*pz)+((x817*x818))+(((-0.0054675)*cj3*x815)))),IKFAST_ATAN2_MAGTHRESH);
if(!x828.valid){
continue;
}
CheckValue<IkReal> x829=IKPowWithIntegerCheck(IKsign(((((0.0405)*x817*x819))+(((0.1595)*pz))+(((-0.0405)*x819*x820))+(((-0.0405)*x820*x823))+(((-1.0)*x819*x824))+(((-1.0)*x823*x824))+(((0.0405)*x817*x823))+(((-1.0)*cj2*sj3*x821))+(((-1.0)*x821*x825))+(((-0.0675)*pz*sj2)))),-1);
if(!x829.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x828.value)+(((1.5707963267949)*(x829.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x830=IKsin(j1);
IkReal x831=IKcos(j1);
IkReal x832=(cj0*px);
IkReal x833=((0.0405)*cj3);
IkReal x834=((0.0675)*sj2);
IkReal x835=(py*sj0);
IkReal x836=((0.0675)*cj2);
IkReal x837=((0.0405)*cj2*sj3);
IkReal x838=(sj2*x833);
IkReal x839=((1.0)*x831);
IkReal x840=((0.0405)*sj2*sj3);
IkReal x841=(cj2*x831);
IkReal x842=(pz*x831);
IkReal x843=(x830*x835);
evalcond[0]=((-0.1595)+((x830*x832))+x834+x837+x838+x843+x842);
evalcond[1]=((((-1.0)*x832*x839))+(((-1.0)*x835*x839))+((pz*x830))+(((-1.0)*x840))+x836+((cj2*x833)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x830*x832))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((0.319)*x842))+(((0.319)*x843))+(((-1.0)*(py*py))));
evalcond[3]=(((x831*x837))+((x831*x834))+((x831*x838))+(((-1.0)*x830*x840))+pz+((x830*x836))+(((-0.1595)*x831))+((cj2*x830*x833)));
evalcond[4]=((((-1.0)*x831*x840))+((x831*x836))+((x833*x841))+(((-1.0)*x830*x834))+(((-1.0)*x830*x837))+(((-1.0)*x830*x838))+(((-1.0)*x832))+(((-1.0)*x835))+(((0.1595)*x830)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x844=py*py;
IkReal x845=cj0*cj0;
IkReal x846=((0.0405)*sj3);
IkReal x847=(cj2*pz);
IkReal x848=(cj0*px);
IkReal x849=(py*sj0);
IkReal x850=((0.0675)*cj2);
IkReal x851=((0.0405)*cj3);
IkReal x852=(pz*sj2);
IkReal x853=(sj2*x848);
IkReal x854=(cj2*x851);
CheckValue<IkReal> x855=IKPowWithIntegerCheck(IKsign(((((-1.0)*x845*(px*px)))+(((-1.0)*(pz*pz)))+(((-2.0)*x848*x849))+(((-1.0)*x844))+((x844*x845)))),-1);
if(!x855.valid){
continue;
}
CheckValue<IkReal> x856 = IKatan2WithCheck(IkReal(((((-1.0)*x846*x852))+((sj2*x849*x851))+((cj2*x846*x849))+((cj2*x846*x848))+((x847*x851))+(((0.0675)*x847))+((x851*x853))+(((-0.1595)*x848))+(((-0.1595)*x849))+(((0.0675)*sj2*x849))+(((0.0675)*x853)))),IkReal((((sj2*x846*x849))+((x846*x847))+(((-1.0)*x849*x854))+(((-1.0)*x849*x850))+(((-1.0)*x848*x854))+(((-1.0)*x848*x850))+((x851*x852))+((x846*x853))+(((-0.1595)*pz))+(((0.0675)*x852)))),IKFAST_ATAN2_MAGTHRESH);
if(!x856.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x855.value)))+(x856.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x857=IKsin(j1);
IkReal x858=IKcos(j1);
IkReal x859=(cj0*px);
IkReal x860=((0.0405)*cj3);
IkReal x861=((0.0675)*sj2);
IkReal x862=(py*sj0);
IkReal x863=((0.0675)*cj2);
IkReal x864=((0.0405)*cj2*sj3);
IkReal x865=(sj2*x860);
IkReal x866=((1.0)*x858);
IkReal x867=((0.0405)*sj2*sj3);
IkReal x868=(cj2*x858);
IkReal x869=(pz*x858);
IkReal x870=(x857*x862);
evalcond[0]=((-0.1595)+((x857*x859))+x869+x865+x864+x861+x870);
evalcond[1]=((((-1.0)*x867))+((cj2*x860))+(((-1.0)*x862*x866))+(((-1.0)*x859*x866))+x863+((pz*x857)));
evalcond[2]=((-0.01924375)+(((-1.0)*(px*px)))+(((0.319)*x857*x859))+(((0.319)*x869))+(((0.319)*x870))+(((0.0054675)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[3]=((((-0.1595)*x858))+((cj2*x857*x860))+((x858*x865))+((x858*x864))+((x858*x861))+pz+((x857*x863))+(((-1.0)*x857*x867)));
evalcond[4]=((((-1.0)*x859))+(((-1.0)*x862))+(((0.1595)*x857))+((x858*x863))+(((-1.0)*x858*x867))+((x860*x868))+(((-1.0)*x857*x861))+(((-1.0)*x857*x864))+(((-1.0)*x857*x865)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "db618040b15e3c832c6e639c3212612f"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
